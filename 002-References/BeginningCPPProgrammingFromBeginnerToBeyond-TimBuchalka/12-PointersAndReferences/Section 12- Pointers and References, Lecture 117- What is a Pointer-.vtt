WEBVTT

00:00:05.740 --> 00:00:08.870
Before we get into any c++
code that uses pointers,

00:00:09.080 --> 00:00:10.339
let's see what a pointer is.

00:00:10.849 --> 00:00:12.060
A pointer is a variable.

00:00:12.740 --> 00:00:14.470
Okay, we know all about variables.

00:00:14.860 --> 00:00:17.199
Variables have an address in
memory where they're bound to.

00:00:17.430 --> 00:00:20.980
They also have a type, such as int,
double, string, vector and so forth.

00:00:21.450 --> 00:00:23.140
And they have a value,
which they store.

00:00:23.790 --> 00:00:26.950
A pointer is a variable and
it stores the address of

00:00:26.950 --> 00:00:28.559
another variable or function.

00:00:29.429 --> 00:00:33.319
So if I initialize an integer
variable named x to 10 then

00:00:33.380 --> 00:00:36.600
x is of type integer and it's
bound to some memory location,

00:00:36.799 --> 00:00:38.250
and it contains the value 10.

00:00:38.910 --> 00:00:41.010
That means that I can declare
a pointer variable that

00:00:41.010 --> 00:00:42.530
stores the address of x.

00:00:43.660 --> 00:00:44.970
So a pointer is a variable.

00:00:45.080 --> 00:00:47.970
That means that the pointer has a
memory location where it's bound to.

00:00:48.309 --> 00:00:52.519
It has a type, it has a value,
and the value is an address.

00:00:53.199 --> 00:00:56.230
We'll see how to declare a
pointer in c++ in the next video.

00:00:56.580 --> 00:00:59.450
Remember that a pointer points
to a variable or to a function.

00:00:59.780 --> 00:01:02.660
To use the pointer, you must know
the type of what it points to.

00:01:03.340 --> 00:01:06.079
Before we learn about how to
use pointers, let's see why we

00:01:06.080 --> 00:01:07.470
use pointers in the first place.

00:01:09.150 --> 00:01:12.079
If a pointer points to a
variable or a function, can't

00:01:12.080 --> 00:01:15.300
i just use the variable or
the function directly, sure.

00:01:15.690 --> 00:01:16.930
And if you can, you should.

00:01:17.240 --> 00:01:19.360
There is no sense in creating
a pointer to something

00:01:19.360 --> 00:01:20.500
that you can use directly.

00:01:20.970 --> 00:01:22.349
But you can't always do that.

00:01:22.719 --> 00:01:26.699
For example, if you have some complex
data that's defined outside a function

00:01:27.049 --> 00:01:30.680
and you want to access that data from
within the function, you can't because

00:01:30.690 --> 00:01:32.100
the variable name is out of scope.

00:01:32.700 --> 00:01:35.710
So you can pass the data to the
function by value and make a copy

00:01:35.710 --> 00:01:39.440
of it or you can use a reference
or a pointer parameter to access

00:01:39.440 --> 00:01:41.070
that data from within the function.

00:01:41.860 --> 00:01:45.169
Also pointers are often used to
operate on arrays very efficiently.

00:01:45.380 --> 00:01:48.249
In fact, we'll see in this
section just how interrelated

00:01:48.250 --> 00:01:49.530
pointers and arrays are.

00:01:50.480 --> 00:01:53.350
We can use pointers to allocate
memory from the heap or the free

00:01:53.350 --> 00:01:55.070
story dynamically at runtime.

00:01:55.570 --> 00:01:58.179
That memory doesn't have a
variable name associated with it.

00:01:58.360 --> 00:02:00.389
So the only way to use
it is through a pointer.

00:02:00.860 --> 00:02:03.710
Finally, if you're working with
embedded systems, device drivers

00:02:03.710 --> 00:02:07.080
or other types of system software,
sometimes you need to gain access

00:02:07.080 --> 00:02:10.639
to a specific memory address
or a range of memory addresses.

00:02:10.919 --> 00:02:12.570
Pointers is the best way to do that.

00:02:13.420 --> 00:02:16.170
Okay, now that we know a little
bit more about what a pointer is

00:02:16.400 --> 00:02:19.200
and why we would use one, let's
see how we can declare a pointer

00:02:19.200 --> 00:02:20.300
variable in the next video.

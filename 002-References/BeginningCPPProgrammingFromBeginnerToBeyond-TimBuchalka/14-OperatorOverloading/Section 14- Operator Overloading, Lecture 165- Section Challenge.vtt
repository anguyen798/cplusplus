WEBVTT

00:00:05.300 --> 00:00:08.469
Hello, everyone. Welcome to the section 14 challenge.

00:00:08.710 --> 00:00:11.450
Congratulations on finishing
up this part of the course.

00:00:12.270 --> 00:00:14.619
I'm in the section 14 workspace.

00:00:14.799 --> 00:00:16.899
And you can see that I have
a challenge project, and

00:00:16.900 --> 00:00:19.490
this is the basic shell that
I want to talk about now.

00:00:20.150 --> 00:00:23.540
There's also a challenge solution
one and a challenge solution

00:00:23.540 --> 00:00:25.900
two, and I'll talk about those
projects in just a second.

00:00:26.230 --> 00:00:28.689
So the whole idea with this
challenge is for you to overload

00:00:28.689 --> 00:00:30.490
operators for the mystring class.

00:00:30.820 --> 00:00:34.289
Now I'm providing a basic
mystring class that's got all the

00:00:34.289 --> 00:00:37.699
constructors, your move constructors,
your assignment operators.

00:00:37.880 --> 00:00:41.290
And I've even overloaded the insertion
and extraction operators just to make

00:00:41.290 --> 00:00:43.090
it easier for you to test your code.

00:00:43.450 --> 00:00:45.269
So let's talk about this challenge.

00:00:46.269 --> 00:00:49.280
The purpose of the challenge for
you to gain experience overloading

00:00:49.309 --> 00:00:52.789
operators, and I would recommend that
you do this challenge twice that's

00:00:52.789 --> 00:00:54.389
why we have two solutions here.

00:00:54.720 --> 00:00:58.380
The first time do it by overloading
the operators using member functions

00:00:58.760 --> 00:01:01.680
and then start a new project
and do the same thing but this

00:01:01.680 --> 00:01:03.309
time use non-member functions.

00:01:03.790 --> 00:01:06.830
Okay, so let's talk about some of the
operators that you could overload.

00:01:07.230 --> 00:01:09.000
Now I'm just giving
you an example here.

00:01:09.009 --> 00:01:11.300
You can certainly do whatever
you like, whatever makes

00:01:11.300 --> 00:01:14.590
sense to you as crazy as you
like, this is just to learn.

00:01:14.590 --> 00:01:17.170
So be as creative as you like.

00:01:17.320 --> 00:01:19.070
But here's a couple of examples.

00:01:19.290 --> 00:01:24.880
We've already done the unary minus
in the slides in the examples.

00:01:25.080 --> 00:01:26.750
All it does is makes
a string lowercase.

00:01:28.789 --> 00:01:30.670
Here's the example for equality.

00:01:30.670 --> 00:01:33.750
We want to compare two
strings, s1 and s2.

00:01:33.780 --> 00:01:38.780
Now obviously, this will call
s1.operator,

00:01:41.000 --> 00:01:44.800
the equality operator with s2, right.

00:01:44.830 --> 00:01:46.390
And this is assuming
the member method.

00:01:46.789 --> 00:01:50.230
So remember, all of these operators
that we're talking about get mapped to

00:01:50.230 --> 00:01:53.690
some function whether it be a member
function or a non-member function,

00:01:53.720 --> 00:01:55.230
just as we talked about in the class.

00:01:55.750 --> 00:01:58.529
So that's the equality operator.

00:01:58.719 --> 00:02:02.240
Then we're also going to have the
not equal operator, which just checks

00:02:02.250 --> 00:02:03.840
to see if two strings are not equal.

00:02:04.029 --> 00:02:07.789
So in the case of s1 being Joe and
s2 being Frank, this will return

00:02:07.800 --> 00:02:08.959
true because they're not equal.

00:02:09.729 --> 00:02:12.700
Then we've got the less than and
greater than operators, which

00:02:12.700 --> 00:02:14.170
just test strings lexically.

00:02:14.200 --> 00:02:20.600
So for example, if I've got frank and
I've got George, frank will be less

00:02:20.600 --> 00:02:22.499
than George since f is less than g.

00:02:22.730 --> 00:02:24.970
You get the idea, just
basic string comparison.

00:02:25.500 --> 00:02:27.980
We can also do the greater than
equal to or less than or equal

00:02:27.980 --> 00:02:29.880
to, I'll leave those up to
you if you choose to do them.

00:02:30.510 --> 00:02:33.080
We've got concatenation
which we've already done.

00:02:33.500 --> 00:02:37.019
But again, I haven't done any of these
so you can get experience doing them.

00:02:37.179 --> 00:02:39.360
I'd recommend that you try to do
them by yourself without going

00:02:39.370 --> 00:02:41.389
back to the slides and looking
at the code we've written.

00:02:41.400 --> 00:02:44.040
That way you get a little bit
you know better feel for how

00:02:44.040 --> 00:02:46.220
to overload the operators and
how they work with the code.

00:02:47.110 --> 00:02:48.790
We've got the plus equal operator.

00:02:48.790 --> 00:02:52.340
This is an interesting operator
because it's s1 plus equals s2.

00:02:52.350 --> 00:02:56.220
So this is the same as
s1 equals s1 plus s2.

00:02:56.520 --> 00:03:00.079
Okay, then I've got this operator here.
And this one may be a little confusing.

00:03:00.079 --> 00:03:01.710
So I'm going to take a
second to talk about it.

00:03:02.370 --> 00:03:05.739
The idea here is that
we have s2 times 3.

00:03:05.810 --> 00:03:07.150
And this is an integer here.

00:03:08.290 --> 00:03:12.586
And the idea would be if I have s2
being abc, then s2 times 3 is going

00:03:12.740 --> 00:03:14.122
to give me three copies of abc.

00:03:14.122 --> 00:03:17.359
It's going to repeat that
string whatever it is n times

00:03:17.379 --> 00:03:19.180
where n is this guy right here.

00:03:19.620 --> 00:03:21.420
So this could be a
pretty handy operator.

00:03:21.800 --> 00:03:25.090
So s1 equals s2 times 3, what's
going to happen is, you're

00:03:25.090 --> 00:03:29.709
going to get abc, abc, abc, and
then it gets assigned to s1.

00:03:29.710 --> 00:03:33.470
Okay, so the last one is
the star equal operator.

00:03:33.860 --> 00:03:37.150
Here we're going to repeat the string
on the left-hand side and times.

00:03:37.520 --> 00:03:38.519
So it's really simple.

00:03:38.520 --> 00:03:44.769
So if s1 is abc, then s1 star
equal 4 gives me 4 abcs, not 5.

00:03:45.200 --> 00:03:47.480
We're not really assigning
back to the original s1.

00:03:47.690 --> 00:03:49.670
If you want to do that, that
would be perfectly fine.

00:03:49.960 --> 00:03:53.899
But in this case, it's really
easy to think repeat s1 four times

00:03:53.900 --> 00:03:55.290
and store it right back in s1.

00:03:55.700 --> 00:03:56.560
So it's pretty handy.

00:03:57.050 --> 00:03:59.429
And then the last operators we'll
talk about are the increment

00:03:59.429 --> 00:04:00.920
and decrement operators.

00:04:01.860 --> 00:04:04.150
I haven't really talked about
them too much in this class,

00:04:04.150 --> 00:04:05.219
but I'll talk about them now.

00:04:05.670 --> 00:04:09.670
And the idea here is that -- remember,
these are increment and decrement

00:04:09.710 --> 00:04:12.990
operators and we have pre and
post versions of each one.

00:04:14.340 --> 00:04:16.570
Now assuming that we've got
member versions and that's

00:04:16.570 --> 00:04:19.000
what I'm talking about here,
member method versions of these.

00:04:19.250 --> 00:04:20.899
These are the semantics for this.

00:04:21.360 --> 00:04:23.350
You'll notice we have
operator plus plus.

00:04:23.750 --> 00:04:26.790
And then we've got operator
plus plus with an int.

00:04:27.270 --> 00:04:28.790
That int is not used.

00:04:29.059 --> 00:04:31.159
It's not even named,
it's just a placeholder.

00:04:31.159 --> 00:04:33.850
And the compiler is using that
behind the scenes to be able to

00:04:33.850 --> 00:04:37.490
tell the difference between these
two prototypes if you will because

00:04:37.490 --> 00:04:40.200
otherwise it'd be exactly the same and
it wouldn't know which one to call.

00:04:40.860 --> 00:04:43.520
So this guy right here
is the pre-increment.

00:04:44.080 --> 00:04:46.880
And the way that this works is
the semantics are really clear.

00:04:47.379 --> 00:04:49.280
You do whatever you
want increment to do.

00:04:49.670 --> 00:04:52.440
I'm making it make all the
characters uppercase in

00:04:52.440 --> 00:04:53.810
the in the current object.

00:04:54.760 --> 00:04:58.100
And then you return this because
you're actually modifying

00:04:58.100 --> 00:05:01.150
that object before you go
back to the caller, right.

00:05:01.150 --> 00:05:02.429
That's what pre-increment does.

00:05:03.190 --> 00:05:06.579
Now the semantics for post-increment
are a little bit different.

00:05:06.590 --> 00:05:08.790
And let me just scroll up just a
little here so you can probably

00:05:08.790 --> 00:05:10.020
see it a little more clearly.

00:05:10.550 --> 00:05:11.060
Here we go.

00:05:11.880 --> 00:05:14.930
Now the semantics for the post
increment are a little bit different.

00:05:14.930 --> 00:05:17.150
We need to make a copy
of what we've got now.

00:05:17.830 --> 00:05:20.669
Then we call operator plus plus.

00:05:20.770 --> 00:05:22.799
Notice that this doesn't
have an int in there, right.

00:05:23.010 --> 00:05:24.700
So we're calling pre-increment.

00:05:24.710 --> 00:05:25.840
That's really important.

00:05:26.120 --> 00:05:30.080
If you call post increment, you end up
with a recursive loop here and you're

00:05:30.080 --> 00:05:31.000
never going to get out of there.

00:05:31.810 --> 00:05:34.330
So what we're doing is we're
incrementing, we're doing a

00:05:34.330 --> 00:05:36.900
pre-increment, and then we're
returning this temporary

00:05:36.900 --> 00:05:39.300
object that we saved, which
is the old copy, right.

00:05:39.900 --> 00:05:43.130
And that's exactly what the the
whole idea with post increment means.

00:05:43.170 --> 00:05:44.590
So that's the semantics of that.

00:05:45.500 --> 00:05:47.840
And then the rest is
pretty straightforward.

00:05:47.860 --> 00:05:48.680
Have fun.

00:05:48.910 --> 00:05:51.280
Think of some other operators
that might be useful.

00:05:51.620 --> 00:05:53.730
It doesn't matter if
they make sense or not.

00:05:53.750 --> 00:05:55.880
This is all about learning
how to overload operators.

00:05:55.880 --> 00:05:57.810
So be as crazy and
creative as you want to be.

00:05:58.789 --> 00:05:59.470
Some hints.

00:05:59.859 --> 00:06:02.920
Take advantage of the std
string compare function

00:06:03.170 --> 00:06:04.489
for the equality operators.

00:06:04.500 --> 00:06:08.240
Remember that guy returns 0 if
they're equal, negative something

00:06:08.240 --> 00:06:10.480
or positive something if they're
greater than or less than.

00:06:10.480 --> 00:06:12.480
I'll let you guys look that
up so you can learn about it.

00:06:13.630 --> 00:06:16.110
Another thing is the plus
equal and star equals

00:06:16.110 --> 00:06:18.420
operators should return a ref.

00:06:18.420 --> 00:06:21.220
Okay, that's really important
because we want to be able to chain,

00:06:21.220 --> 00:06:22.890
and we don't want extra copies.

00:06:24.080 --> 00:06:27.570
Finally, when you're doing
plus sequel and star equal,

00:06:27.860 --> 00:06:31.150
rather than duplicate all your
code again, use plus and star.

00:06:31.330 --> 00:06:32.760
We've already used those operators.

00:06:32.760 --> 00:06:37.250
We've already implemented them,
and if you do that these operators,

00:06:37.250 --> 00:06:40.530
when you go to overlay these
operators right here, the code

00:06:40.530 --> 00:06:41.799
really becomes almost trivial.

00:06:41.800 --> 00:06:43.010
It's just a line or two of code.

00:06:43.010 --> 00:06:44.230
It's really, really straightforward.

00:06:44.570 --> 00:06:47.330
One more thing I want to mention
is when you do your increment and

00:06:47.440 --> 00:06:53.929
decrement operators, make sure that
the pre-increment right here returns

00:06:53.940 --> 00:06:58.810
a ref, and make sure that the post
increment does not return a ref, it

00:06:58.810 --> 00:07:01.880
should return a mystring by value.

00:07:02.610 --> 00:07:04.279
Okay, so that's basically it.

00:07:04.280 --> 00:07:07.800
Let me go over the mystring
class so that you can see

00:07:07.800 --> 00:07:09.050
where the starting point is.

00:07:09.420 --> 00:07:11.810
This should be really familiar
now after this section.

00:07:11.969 --> 00:07:13.149
There's the mystring class.

00:07:13.150 --> 00:07:16.480
You can see that I've overloaded
the insertion and extraction

00:07:16.480 --> 00:07:18.969
operators as friend functions.

00:07:19.820 --> 00:07:22.190
Here's mystring class, and
it's got nothing that you

00:07:22.190 --> 00:07:23.059
wouldn't expect, right.

00:07:23.059 --> 00:07:26.179
It's got all the constructors, the
move constructor, the assignment

00:07:26.179 --> 00:07:30.240
operators, both the copy and the move
and your getters on your display.

00:07:30.240 --> 00:07:32.320
You shouldn't even have to use
display anymore because now

00:07:32.320 --> 00:07:34.049
we've got this guy right here.

00:07:35.430 --> 00:07:37.210
Okay, so that's about it.

00:07:37.260 --> 00:07:41.020
If you look at implementation, again,
it's exactly like we've done in class.

00:07:41.099 --> 00:07:44.320
The one thing that I have done
is I've commented out these

00:07:44.380 --> 00:07:47.700
output statements using copy
assignment using move assignments.

00:07:47.700 --> 00:07:50.830
But I left them in there in case
you want to uncomment them and

00:07:50.830 --> 00:07:53.340
trace your code or you can use
the debugger to trace your code.

00:07:53.690 --> 00:07:54.620
I'll leave that up to you.

00:07:55.400 --> 00:07:57.150
The last thing is here's the main.

00:07:57.150 --> 00:07:58.230
Here's a real sample name.

00:07:58.230 --> 00:08:01.869
And I've commented the entire main
out so that you can uncomment as you

00:08:01.870 --> 00:08:03.909
go or create your own test cases and.

00:08:03.910 --> 00:08:05.839
Here's some simple
test cases for this.

00:08:06.270 --> 00:08:09.710
By no means, these are exhaustive
but they'll certainly you know begin

00:08:09.710 --> 00:08:12.090
to test your overload operators.

00:08:12.250 --> 00:08:13.870
So let me go through a couple of them.

00:08:14.190 --> 00:08:16.489
You can see right here, I've
got a string a frank, I've

00:08:16.490 --> 00:08:19.490
got a string b frank they're. They're the same string right,

00:08:19.490 --> 00:08:21.690
so in this case, I'm comparing a to b.

00:08:21.990 --> 00:08:24.990
I expect that to be true
since they're both frank.

00:08:25.350 --> 00:08:28.400
And I'm asking is a not equal
to b, well, that's false

00:08:28.420 --> 00:08:29.590
because they are equal, right.

00:08:29.590 --> 00:08:33.470
So what you see over here in the
comments is what I expect as output.

00:08:34.169 --> 00:08:35.789
Now we create b as george.

00:08:35.830 --> 00:08:37.059
Remember, a is still frank.

00:08:37.980 --> 00:08:38.989
Are a and b equal?

00:08:39.070 --> 00:08:39.650
No, they're not.

00:08:40.869 --> 00:08:42.000
Is a not equal to b?

00:08:42.039 --> 00:08:42.789
That's correct.

00:08:43.620 --> 00:08:44.710
Is a less than b?

00:08:44.720 --> 00:08:48.840
Well, a is frank b is george, the f
comes before the g, so this is true.

00:08:49.310 --> 00:08:50.510
Is a greater than b?

00:08:50.510 --> 00:08:51.299
This is false.

00:08:51.330 --> 00:08:52.190
You get the idea.

00:08:52.860 --> 00:08:56.219
So these are just some sample test
cases that you can use along the way.

00:08:56.549 --> 00:09:00.470
And then I've got some other ones that
are testing the the negation operator

00:09:00.470 --> 00:09:02.140
right here, the unary minus, right.

00:09:02.140 --> 00:09:03.030
So s1 is frank.

00:09:03.030 --> 00:09:07.490
And then I'm just saying s1 equals
minus s1, which makes s1 lowercase.

00:09:07.720 --> 00:09:10.000
So when I output it, I
expect frank in lowercase.

00:09:11.480 --> 00:09:13.260
There's my concatenation operator.

00:09:13.270 --> 00:09:15.420
Right now frank is
lowercase that's s1.

00:09:15.450 --> 00:09:18.719
I'm just adding a bunch of
asterisks to the end, displaying it.

00:09:18.830 --> 00:09:19.839
That's what I expect.

00:09:20.530 --> 00:09:23.050
I'm doing it again, but this
time I'm using plus equal,

00:09:23.060 --> 00:09:26.230
which just means added these
dashes to the left-hand side.

00:09:26.240 --> 00:09:28.159
Well, the left-hand side
is this guy right here.

00:09:28.400 --> 00:09:30.670
So you can see the dash
is being added right here.

00:09:32.370 --> 00:09:34.000
Okay, here's another example.

00:09:34.400 --> 00:09:36.390
S2 is 1 2 3 4 5,

00:09:36.890 --> 00:09:40.070
and what this says is repeat s2 three times

00:09:40.070 --> 00:09:41.570
and then store it into s1.

00:09:41.810 --> 00:09:48.300
So when i display s1, I'm seeing 1 2 3
4 5, 1 2 3 4 5 1 2 3 4 5, three times.

00:09:50.509 --> 00:09:53.270
And I think there's a couple
of more test cases down

00:09:53.270 --> 00:09:54.319
here that we can talk about.

00:09:54.789 --> 00:09:58.950
And again, I encourage you to come
up with your own test cases and write

00:09:59.160 --> 00:10:02.469
some tests that really test this
and exercise the code so you can be

00:10:02.470 --> 00:10:03.700
sure that it's working correctly.

00:10:04.630 --> 00:10:07.189
Here's another one s3 is abcdef.

00:10:07.189 --> 00:10:12.140
And the semantics of this one
just says hey repeat whatever's

00:10:12.140 --> 00:10:13.310
on the left five times.

00:10:13.369 --> 00:10:15.490
So whatever's on the left is abcdef.

00:10:15.690 --> 00:10:19.990
So we're going 1 2 3 4 5.

00:10:21.660 --> 00:10:24.460
Okay, now here's some tests
with the increment operators.

00:10:24.460 --> 00:10:26.110
I haven't done the decrement operator.

00:10:26.110 --> 00:10:27.480
I'll leave that totally up to you.

00:10:27.849 --> 00:10:30.050
We already have a unitary
minus that makes it lowercase.

00:10:30.490 --> 00:10:32.240
But you could do whatever you like.

00:10:32.240 --> 00:10:33.460
Remember, we're programmers.

00:10:33.460 --> 00:10:34.260
We can do anything.

00:10:34.540 --> 00:10:37.599
So you can make that decrement
operator behave how however you like.

00:10:37.970 --> 00:10:41.369
So let's take a look at
this mystring s is frank.

00:10:41.759 --> 00:10:44.319
And then I'm doing an increment
in this case a pre-increment.

00:10:44.349 --> 00:10:51.100
Remember, when we have plus plus s or
s plus plus all alone on a line, it

00:10:51.100 --> 00:10:52.770
means exactly the same thing, right.

00:10:52.770 --> 00:10:55.800
The pre the post don't mean
much it's just increment s.

00:10:56.160 --> 00:11:00.350
So in this case, you can see
s is frank with a capital f.

00:11:01.040 --> 00:11:04.000
Then I'm saying pre-increment
s at this point.

00:11:04.020 --> 00:11:07.200
When I output s, I expect all
uppercase characters, which

00:11:07.200 --> 00:11:08.560
is what our semantics say.

00:11:09.390 --> 00:11:12.040
Over here, I'm decrementing
s using unity minus.

00:11:12.040 --> 00:11:13.920
So I'm putting it right
back to lowercase.

00:11:14.179 --> 00:11:18.190
You could make -- you could
do something like minus minus s if you like

00:11:18.290 --> 00:11:20.280
to do the same
thing as the unary minus.

00:11:20.280 --> 00:11:21.769
But again, I'll leave
that up to you guys.

00:11:22.709 --> 00:11:24.689
And now I've got result.

00:11:25.129 --> 00:11:33.270
And here I'm saying result plus
-- equals, sorry pre-increment s.

00:11:34.580 --> 00:11:37.319
And remember, s right
now is frank lowercase.

00:11:38.160 --> 00:11:39.240
That's what s is.

00:11:39.690 --> 00:11:42.330
So I want to pre-increment s
that means I want to make s

00:11:42.340 --> 00:11:44.707
uppercase and then assign it.

00:11:44.707 --> 00:11:46.160
That's what the pre-increment does.

00:11:46.420 --> 00:11:48.370
Make s uppercase then assign it.

00:11:48.380 --> 00:11:52.204
So when I display both those values,
I expect them both to be uppercase

00:11:52.490 --> 00:11:53.549
and that's what's happening here.

00:11:54.730 --> 00:11:57.439
And let me scroll up just a
little bit right around line 54.

00:11:59.670 --> 00:12:02.729
And in this case, we're
doing a post increment.

00:12:02.750 --> 00:12:04.709
Again, here it's the same
as the pre-increment.

00:12:04.710 --> 00:12:06.489
So I expect frank to be uppercase.

00:12:06.970 --> 00:12:08.690
Now I make frank lower case again.

00:12:08.690 --> 00:12:11.100
So s is frank in lowercase.

00:12:12.500 --> 00:12:18.829
And now what we're doing is
result equals s post incremented.

00:12:19.150 --> 00:12:24.040
So what we do is first we assign s
over to result, then we increment s.

00:12:24.300 --> 00:12:27.899
So when I assign s over to result,
result should be lowercase frank,

00:12:27.899 --> 00:12:32.080
and you can see it is right here
and s should be now uppercase

00:12:32.950 --> 00:12:34.550
franc because I just moved it over.

00:12:36.100 --> 00:12:37.200
Okay, so there you go.

00:12:37.210 --> 00:12:39.190
That's a quick intro to the challenge.

00:12:39.460 --> 00:12:41.070
This could be a pretty long challenge.

00:12:41.070 --> 00:12:42.270
Take it one step at a time.

00:12:42.310 --> 00:12:44.230
Do the operators do
the easy ones first.

00:12:44.610 --> 00:12:47.140
I would suggest to do the quality
operators first because they're

00:12:47.270 --> 00:12:51.979
pretty straightforward and then make
sure that you do your star operator,

00:12:51.980 --> 00:12:55.560
which means repeat in this case
and your concatenation operator.

00:12:55.870 --> 00:12:59.350
Do those before you do plus equal
and star equal, that way you can

00:12:59.350 --> 00:13:03.280
take advantage of them and really
make the code much, much simpler.

00:13:04.260 --> 00:13:05.689
Okay, so I'll be back.

00:13:06.290 --> 00:13:07.160
Have a go at this.

00:13:07.179 --> 00:13:08.709
And when you're done,
you can come back.

00:13:08.710 --> 00:13:13.290
And solution one will be the
version where we've got member

00:13:13.320 --> 00:13:17.040
methods, and solution two is the
version where we've got non-member

00:13:17.040 --> 00:13:20.130
methods or basically non-member
functions global functions.

00:13:20.849 --> 00:13:22.610
All right, so have fun and good luck.

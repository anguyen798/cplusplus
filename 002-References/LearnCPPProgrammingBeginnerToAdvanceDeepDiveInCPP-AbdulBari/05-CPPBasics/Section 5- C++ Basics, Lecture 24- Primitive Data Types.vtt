WEBVTT

0
00:00.330 --> 00:05.670
Let us learn about the data types available in C++ language already in  the previous video I have given

1
00:05.670 --> 00:12.330
you the reason or the idea why we need to get data types every language supports data type.

2
00:12.340 --> 00:13.230
without data type

3
00:13.240 --> 00:17.330
There is no use of writing the programs so let us learn what are the data types then,

4
00:17.330 --> 00:22.810
Also we will learn how to use them means how to use them by declaring the variables.

5
00:22.830 --> 00:27.820
So let us get going what have you of all the data types available in C++.

6
00:28.080 --> 00:34.790
I have a chart here that is showing the data types then, in this they can be categorized in to 3.

7
00:34.810 --> 00:36.850
Now majorly you have to understand this one.

8
00:36.900 --> 00:44.370
This portion, data types are called primitive data types primitive means in house, living, the one

9
00:44.370 --> 00:48.890
which are living inside C++ so that are directly provided by compiler.

10
00:49.200 --> 00:54.540
So primitive data types are basic data types of C++.

11
00:54.540 --> 01:00.480
They are of three types that is categorization again integral type integral which means there

12
01:00.480 --> 01:01.730
is no decimal point.

13
01:02.190 --> 01:09.800
Boolean means true or false next, floating point with the decimal decimal is also called Floating Point.

14
01:10.380 --> 01:17.560
So this is the broader categorization, under integral we have int and char.

15
01:17.680 --> 01:18.990
Character is integral.

16
01:19.170 --> 01:19.770
I will show you.

17
01:19.800 --> 01:26.250
What does it mean, integer and character comes under integral means that they will not have a decimal

18
01:26.250 --> 01:27.080
point.

19
01:27.090 --> 01:30.950
Yes then floating point there are two float and double.

20
01:30.960 --> 01:34.920
They are similar only just some difference are there, we will learn about it.

21
01:35.190 --> 01:42.100
So before going into details of this let us have a look at these also. user defined data types are 

22
01:42.110 --> 01:42.880
available

23
01:43.050 --> 01:47.730
First one is enum. enumeration that you will find in this section only right.

24
01:47.990 --> 01:50.490
And structure and union.

25
01:50.490 --> 01:53.070
These are anlother one and classes.

26
01:53.070 --> 02:00.780
That's what the C++ is for, C++ supports object orientation so actual C++ concepts and the programming starts

27
02:00.780 --> 02:01.940
from classes.

28
02:02.080 --> 02:06.500
We will learn a lot of things are there to learn about it, then last, 

29
02:06.510 --> 02:11.190
arrays, pointers and references we have these as a separate topics in some sections so you can

30
02:11.190 --> 02:16.740
check that these are the detailed Lengthy topics so there's all the things are bigger topics.

31
02:16.830 --> 02:18.910
We have a section for each.

32
02:19.050 --> 02:20.490
Now in this video.

33
02:20.490 --> 02:26.560
You have to learn these things the data types and remember now only that is very important right.

34
02:26.610 --> 02:28.310
Because every time we'll be using them.

35
02:28.320 --> 02:31.510
So you should be able to recall what does it mean.

36
02:31.560 --> 02:33.750
So here itself you should learn them.

37
02:33.840 --> 02:35.240
Let us see what are the data types.

38
02:35.340 --> 02:40.950
So for those data types we have to know a few things and among these things you must remember few things.

39
02:40.980 --> 02:42.900
I'll highlight what are the things that you should remember.

40
02:43.020 --> 02:44.760
Let us look at the table.

41
02:44.910 --> 02:51.850
data types are int, float, double, character and boolean and these are their sizes. sizes means 

42
02:52.200 --> 02:58.140
how many bytes of memory they take, like in the previous video I said that if you take only one byte

43
02:58.260 --> 03:00.290
then we can store a small size number.

44
03:00.660 --> 03:02.520
If you want us to a bigger number then what.

45
03:02.910 --> 03:06.120
So that's what depending on the number that you can store.

46
03:06.120 --> 03:11.100
That's what every data type have some number of bytes so this you will learn in detail.

47
03:11.160 --> 03:14.400
That is two bite it take & this take 4 bite, and this take 8 bite .

48
03:14.420 --> 03:15.430
And this take 1 bite.

49
03:15.450 --> 03:16.730
It is undefined.

50
03:16.890 --> 03:24.320
It can be one byte or less. now in each data type depending on the capacity it's its size.

51
03:24.330 --> 03:30.720
There is a possible range of values that it can store so their values are also given so you can

52
03:30.720 --> 03:34.410
note on these one, and out of this.

53
03:34.410 --> 03:41.760
You must remember the range of values for this one and this one. integer, that is, I will read out

54
03:41.760 --> 03:43.910
- 3 2 7 6 8 to

55
03:43.930 --> 03:52.890
3 2 7 6 7. negative, positive so it supports both positive and negative numbers then for character 

56
03:52.900 --> 03:55.260
-128 to 127.

57
03:55.320 --> 04:01.260
This you should remember always next about float and  double if you can remember it's well and good

58
04:01.260 --> 04:06.060
other wise it's not a problem, for float i will read out -3.4*10^-38 and positive one is

59
04:06.090 --> 04:12.030
3.4*10^38 now.

60
04:12.480 --> 04:18.660
Now double is -1.7*10^-308 to 1.7*10^308 .

61
04:18.870 --> 04:24.960
So how do remember them is see double is one point seven, number is one point seven.

62
04:24.990 --> 04:27.070
So if you can remember this is sufficient.

63
04:27.240 --> 04:33.000
Now for float, double that 1.7 it'll become three point four so it is 3.4

64
04:33.000 --> 04:33.970
3.4.

65
04:33.970 --> 04:34.210
Right.

66
04:34.250 --> 04:39.240
How to remember the values I am showing you, then this is 38.

67
04:39.300 --> 04:40.530
So this is 3 0 8.

68
04:40.590 --> 04:42.900
So this way you can remember this one if  at all you want to remember

69
04:42.920 --> 04:47.200
now let us talk about integer see in integer may take.

70
04:47.340 --> 04:54.560
Either two byte it or four byte depending on the version of compiler you are using most of the compilers.

71
04:54.570 --> 05:01.160
Now take four bytes only if you are using turbo c, if you know about it and you are using it

72
05:01.580 --> 05:09.020
then it takes two bytes, turbo c takes two bytes because it opens in DOS box it goes in good dos shell

73
05:09.020 --> 05:13.810
and run there so that it takes two bytes otherwise integer takes four bytes.

74
05:14.180 --> 05:19.070
But in my discussion every time I will be saying int two bytes because when I have to show some

75
05:19.070 --> 05:22.860
calculation and So all two bytes will be easy for me for explanation.

76
05:22.880 --> 05:26.690
Otherwise taking a bigger size data will be difficult for explanation.

77
05:26.690 --> 05:30.000
So I will assume int  takes two bytes every time.

78
05:30.250 --> 05:35.300
Now let us understand how this int is getting this range and this ranges for two bytes not for

79
05:35.300 --> 05:36.070
4 bytes.

80
05:36.080 --> 05:40.760
Let us see how it is taking - 3 2 7 6 8 to 3 2 7 6 7.

81
05:40.850 --> 05:42.110
Let us look at this.

82
05:42.320 --> 05:45.980
It is taking two bytes so two bytes means the total how many bits.

83
05:45.980 --> 05:46.990
Sixteen bits.

84
05:47.020 --> 05:48.790
so i will draw this first.

85
05:48.860 --> 05:50.900
So here they have two bytes.

86
05:50.930 --> 05:53.550
This is first byte,  this the second byte total 16.

87
05:53.560 --> 06:00.170
Bits are there, sixteen bits together, two bytes together works as a single variable in their data that

88
06:00.230 --> 06:04.770
is integer so hold the sixteen bits that use? one of the Bit.

89
06:04.850 --> 06:10.950
This is called As most significant bit and this is called as the least significant bit.

90
06:11.060 --> 06:16.880
So this bit is reserved for assignment, if that is  one means the number is negative.

91
06:16.880 --> 06:22.510
If that is Zero means number is positive then how many bits are remaining for writing a number.

92
06:22.610 --> 06:31.690
Only 15 bits 0 to 14 so 2^15 is 3 2 7 6 8.

93
06:31.850 --> 06:37.530
This is how as a 3 2 7 6 8 and that is up to 3 2 7 6 7.

94
06:37.640 --> 06:43.730
So that's why the number is the store only in 15 bits it has to support sign also positive and

95
06:43.730 --> 06:44.230
negative ALSO.

96
06:44.230 --> 06:47.050
Also that is the reason one bit is reserved.

97
06:47.150 --> 06:49.430
The remaining bits are used for storing a number.

98
06:49.640 --> 06:55.220
So this is common for all the languages not just C++ it is true for C also and this even is true for

99
06:55.220 --> 06:56.480
Java also.

100
06:56.480 --> 07:03.190
It happened similarly in the Java also if two bytes are used anywhere so two bytes if a number is restored

101
07:03.220 --> 07:03.850
in 2 bytes.

102
07:03.860 --> 07:12.490
This is the largest number that we can store. now i will write down the range 0 3 2 7 6 7.

103
07:12.680 --> 07:17.000
If I take the range of this number it will not be starting from 1.

104
07:17.120 --> 07:22.700
I think will be starting from zero so it is 0 to 3 2 7 6 7.

105
07:22.700 --> 07:25.770
That's why it is 7 no next.

106
07:25.850 --> 07:28.520
This has to be in the positive also negative also.

107
07:28.520 --> 07:34.370
So let me write on this so 0 2 3 2 7 6 7.

108
07:34.370 --> 07:40.930
This is positive side than 0 2 3 2 7 6 7.

109
07:41.000 --> 07:44.060
It is a negative side so this is a positive side.

110
07:44.060 --> 07:45.620
This is negative side in this.

111
07:45.620 --> 07:51.230
This is negative means a negative zero will also be that negative zero is not a number.

112
07:51.620 --> 07:58.970
So that's why that negative zero is taken AS minus 3 2 7 6 8.

113
07:59.030 --> 08:02.090
It is assumed as minus 2 equals 7 6 8.

114
08:02.120 --> 08:08.240
It happens automatically in binary number form if the no. is negative and largest then 

115
08:08.240 --> 08:12.790
-3 2 7 6 8 to 3 2 7 6 7.

116
08:12.800 --> 08:18.350
That is the reason we have one number extra here because that -0 has taken as minus 3

117
08:18.350 --> 08:19.770
2 7 6 8.

118
08:19.790 --> 08:21.880
That's how it is getting this range now.

119
08:21.930 --> 08:24.750
This is sufficient for understanding about integer.

120
08:24.800 --> 08:27.350
Now let us come to character.

121
08:27.350 --> 08:27.980
How come.

122
08:27.980 --> 08:33.210
Character is taking numbers minus 128 to127 and it is taking one bite.

123
08:33.260 --> 08:38.110
I'll explain you about it, so character takes one bite so one bite.

124
08:38.110 --> 08:47.930
One bit is of that sign bit, now many how many limits are there 0 to 6 total 7 bits are there2^ 7 is 128 128

125
08:47.990 --> 08:56.010
means 0 to 127 now positive as well as negative so negative 127 negative 0 will also be there.

126
08:56.020 --> 09:00.080
That is the reason minus 128  to 127.

127
09:00.320 --> 09:02.210
This range of character.

128
09:02.700 --> 09:03.370
Let us coming.

129
09:03.370 --> 09:05.110
to the point.

130
09:05.110 --> 09:08.940
How come a character is a no.? see.

131
09:08.950 --> 09:14.110
Computer works on binary no. system, that is zeros and ones so they understand only zeroes and ones

132
09:14.110 --> 09:15.580
nothing else.

133
09:15.580 --> 09:16.320
Right.

134
09:16.450 --> 09:18.430
Then how to represent the character.

135
09:18.640 --> 09:23.490
Character should also be represented in zeros and  those zeros and ones.

136
09:23.500 --> 09:28.340
We understand them as decimal no. system, we understand them as numbers.

137
09:28.450 --> 09:30.730
Then how do we present characters, so for

138
09:30.730 --> 09:34.480
Character codes are given, character codes are to given.

139
09:34.510 --> 09:36.320
So let us see what are codes.

140
09:36.430 --> 09:44.160
The codes are called as ASCII codes or ASIC key codes American standard code for information interchange.

141
09:44.170 --> 09:50.980
So for every alphabet or every letter every letter in the English language as well as the special symbols.

142
09:50.980 --> 09:52.780
There is a code given.

143
09:52.780 --> 09:54.140
So what are those codes.

144
09:54.160 --> 10:01.990
Capital A is represented as sixty five then  B is represented as sixty six so a number

145
10:01.990 --> 10:04.740
is used for representing character.

146
10:04.780 --> 10:08.430
Now if you'll see this the no.  sixty five if you say no no.

147
10:08.440 --> 10:11.020
That is a character means it is A.

148
10:11.020 --> 10:16.560
So only on the screen the printing will be done as A but inside the memory it is sixty five.

149
10:16.610 --> 10:23.060
Its in binary form that all the codes are used for representing characters.

150
10:23.080 --> 10:32.020
capital Z will be  ninety and small a is ninety seven and small b is ninety eight and goes

151
10:32.020 --> 10:39.310
on small z is one thirty two and zero letter 0 on the keyboard.

152
10:39.310 --> 10:46.070
If you see that is also a symbol of character what have you treat it as a number of used them as number

153
10:46.120 --> 10:52.480
but everything on the keyboard is a character so zero is also character so for that symbol is .

154
10:52.480 --> 11:04.440
This is forty eight and one is forty nine and goes on last digit nine is fifty seven.

155
11:04.570 --> 11:11.640
These are the codes now one important thing you must remember these codes you must remember this is

156
11:11.650 --> 11:12.560
very important.

157
11:13.680 --> 11:15.350
You have to remember this range.

158
11:15.450 --> 11:17.360
You have to remember this range.

159
11:17.370 --> 11:19.000
And you should remember these codes.

160
11:19.020 --> 11:20.960
This is very important.

161
11:20.980 --> 11:26.130
All right then for other special symbols also codes are available so you can learn about them.

162
11:26.130 --> 11:31.810
You search in Google you will find out all the list of characters and their codes available.

163
11:31.950 --> 11:36.070
Search for ASCII codes now little more about data types.

164
11:36.120 --> 11:39.210
I would talk about modifiers.

165
11:39.240 --> 11:41.330
Let us discuss about modifiers.

166
11:41.520 --> 11:44.010
There are two modifiers using these modifiers.

167
11:44.010 --> 11:47.410
You can modify these data types as per your requirement.

168
11:47.430 --> 11:49.020
So quickly let us look at this.

169
11:49.020 --> 11:50.610
There are two identifiers.

170
11:50.610 --> 11:51.730
One is unsigned.

171
11:51.900 --> 11:53.590
And another one is long.

172
11:53.940 --> 11:59.460
So you can say unsigned integer.

173
11:59.580 --> 12:05.350
Now this integer which is ticking bought negative as well as positive now it would take only positive.

174
12:05.610 --> 12:10.850
So what are the range 0 to  6 5 5 3 5.

175
12:10.870 --> 12:13.880
This will be the range, double this one double this one.

176
12:13.890 --> 12:16.510
32 thousand you double it 65 thousand

177
12:16.650 --> 12:24.120
So 6 5 5 3 5 is the range 0 to 6 5 5 3 5 means signed bit is not there all 16 bits are used for storing

178
12:24.120 --> 12:26.690
a number integer become unsigned.

179
12:26.700 --> 12:31.770
So if you don't have any negative numbers and you want to get a bigger range you have a larger value

180
12:32.130 --> 12:33.800
then you can go for this.

181
12:34.200 --> 12:37.770
Then you can also see unsigned char.

182
12:38.250 --> 12:44.040
So when you say unsigned character this range you will get double that is you can store the number 0 to

183
12:44.200 --> 12:50.730
255 so you can store the numbers also now if suppose a character you have your numbers are very small

184
12:51.090 --> 12:54.600
instead of storing alphabets you can store a number also in a character.

185
12:54.960 --> 13:01.500
So its range becomes this so unsigned can be used only with integer and character you cannot use it

186
13:01.500 --> 13:02.870
with any other.

187
13:03.210 --> 13:08.190
Next one is long. long you can use it with integer.

188
13:08.190 --> 13:17.460
So if int is taking two bytes then long int will take four bites and if suppose it is taking 4 bytes

189
13:17.550 --> 13:24.570
long int will take eight bytes depending on the compiler already i told you about integer. a long can also

190
13:24.570 --> 13:25.390
be taken with

191
13:25.860 --> 13:37.160
double long double takes 10 bytes see float is for decimal number and if this range is not sufficient

192
13:37.160 --> 13:38.660
does a small number minus three eight.

193
13:38.660 --> 13:39.800
That is five plus three.

194
13:40.110 --> 13:40.750
A small amount.

195
13:41.000 --> 13:43.240
If you want a larger number than you can take double.

196
13:43.340 --> 13:44.900
So it is minus three zero eight .

197
13:44.900 --> 13:45.870
Bigger one.

198
13:45.920 --> 13:50.440
So this is a very small value that is very big value 3 not eight bigger number.

199
13:50.660 --> 13:58.190
If you want is still larger then you can take long double, long float is no meaning because long float

200
13:58.190 --> 14:00.920
itself is double then long double you can take.

201
14:01.010 --> 14:04.250
So it will not be 16 byte it will be 10 byte.

202
14:04.820 --> 14:11.030
So that's all about modifiers modifiers you can use them with limited data types you cannot

203
14:11.030 --> 14:15.770
use unsigned with everything and you cant use along with everything you can not have long char.

204
14:16.250 --> 14:22.550
So that's all about the data types see the end of the course  you will find one section called misellineous

205
14:22.630 --> 14:22.980
there.

206
14:23.090 --> 14:28.430
I have discussed little more about the data types so if you're not a beginner then I suggest you watch

207
14:28.430 --> 14:34.220
that or if you're a beginner after completing the course you watch that section in that section some

208
14:34.220 --> 14:35.880
topics are discussed in more detail.

209
14:35.900 --> 14:39.080
So for the beginners it will be very difficult for them to grasp it.

210
14:39.380 --> 14:44.140
So I have kept them as miscellaneous topic so I suggest you watch those videos.

211
14:44.300 --> 14:50.990
If you want more details about the data types so there are videos for other topics also under misellineous

212
14:50.990 --> 14:51.970
section.

213
14:52.130 --> 14:56.060
Now next we will see variables what are variables.

214
14:56.060 --> 14:57.530
Don't miss this video.

215
14:57.530 --> 14:59.750
So in the next video i will discuss about variables.
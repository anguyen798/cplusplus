WEBVTT

00:00.450 --> 00:01.500
Bitwise operators.

00:01.500 --> 00:03.330
This is one of the interesting topics.

00:03.480 --> 00:09.840
These operations are performed on the bits of the data, not on the whole data as a single unit, but

00:09.840 --> 00:11.370
on the bits of the data.

00:11.520 --> 00:13.950
Let us see what are the operations available?

00:13.980 --> 00:21.540
See, bitwise and bitwise are and bitwise x are.

00:23.510 --> 00:30.620
Our Czar and the bitwise not left to shift and ride shift.

00:32.200 --> 00:34.700
Let me quickly show you how these operations work.

00:34.720 --> 00:40.060
See if there are two bits, a bit of one and a bit to two bits are there.

00:40.210 --> 00:44.590
And if both the bits are zero, then.

00:45.410 --> 00:49.970
Baked one and bitter two will also be zero.

00:50.360 --> 00:53.900
And if any one of the bidders won, then also it is zero.

00:55.640 --> 00:58.830
If this is zero, this is one, then also zero.

00:58.850 --> 01:01.060
And if both are one, then it is one.

01:01.070 --> 01:02.720
So it is just like logical.

01:02.720 --> 01:07.340
And so when you use bitwise ending, it will be one.

01:07.340 --> 01:16.400
If both the bids are one, then if I say or then this will be one if any one of the bidders one.

01:17.120 --> 01:18.230
See, this is one.

01:18.230 --> 01:20.570
So answer is one out of these two bids this is one.

01:20.570 --> 01:22.700
So answer is one or both are one.

01:22.700 --> 01:23.810
So the answer is one.

01:24.890 --> 01:28.940
Then if it is X or this one, then.

01:29.710 --> 01:34.040
If both the bids are different, then only it will be one.

01:34.160 --> 01:37.750
Both the bids are same, then it will be zero.

01:38.230 --> 01:42.670
Exclusive or means exclusively with one is a one.

01:42.850 --> 01:44.680
Then the other bid must be zero.

01:44.710 --> 01:48.250
Or if one bet is zero, then the other bid must be definitely one.

01:48.670 --> 01:53.140
So this is XOR not means whatever the bid is there.

01:53.140 --> 01:54.550
If it is one it will become zero.

01:54.550 --> 01:56.020
If it is zero, it will become one.

01:56.020 --> 01:56.790
Then this.

01:56.950 --> 01:59.860
Let us learn all these operations by using examples.

01:59.860 --> 02:03.250
While explaining that, I'll also explain about the shift operations.

02:03.310 --> 02:08.290
If I have integer variable x and the value is 11.

02:09.850 --> 02:12.850
And the Y value is five.

02:12.910 --> 02:15.940
Now these two integer variables I have taken.

02:16.330 --> 02:20.020
We know that these numbers are actually stored in the binary form.

02:20.020 --> 02:23.200
So what will be the value of X in the binary form?

02:23.200 --> 02:26.200
11 minus one 011.

02:26.620 --> 02:30.460
If I say integer takes two bytes, then it will be total 16 bits.

02:30.460 --> 02:31.870
So four bits are there.

02:31.870 --> 02:35.170
Then the remaining all bits will be zero only.

02:35.170 --> 02:36.700
But I will not write all 16.

02:36.700 --> 02:39.370
But I'll just write eight bits here then.

02:39.370 --> 02:46.530
Same way y value five it is 101 and the remaining bits are all zeros.

02:46.540 --> 02:49.540
So let us understand this upon eight bits only.

02:49.960 --> 02:58.330
And if I use an operation now and try to store the result in one more variable z, let me see what happens

02:58.330 --> 03:11.500
if I say that assign x and y, then these bits are n one and one is 1110 is zero zero and one is 0110

03:11.500 --> 03:12.730
is also zero.

03:12.730 --> 03:15.130
So this will be one.

03:15.250 --> 03:17.290
So binary form it is one.

03:17.290 --> 03:19.600
So Z will get the value of one.

03:20.590 --> 03:23.560
So this is how bitwise ending is performed.

03:23.560 --> 03:28.540
So if you add 11 and five, then the result is one.

03:28.960 --> 03:33.220
I'll change the value instead of five I will take seven.

03:33.490 --> 03:35.170
Let us see what will be the result.

03:35.170 --> 03:38.410
Seven is 111.

03:38.850 --> 03:40.210
Then what will be the result?

03:40.220 --> 03:51.490
111111110 and 101 and zero zero and all these are zeros only then this is how much in binary form this

03:51.490 --> 03:52.120
is one one.

03:52.120 --> 03:54.820
So in decimal form it will be three.

03:55.330 --> 03:58.030
So 11 and seven.

03:58.030 --> 04:03.820
Results three Let us see what will be the result of our operation.

04:03.820 --> 04:13.600
So I will take x 11 only and why seven then instead of and I will use our operation then the result

04:13.600 --> 04:16.060
will be one or one as one.

04:16.060 --> 04:19.360
One or one is one zero or one is also one.

04:19.360 --> 04:21.100
One or zero is also one.

04:21.100 --> 04:23.590
And all these are zeros only.

04:23.590 --> 04:26.920
Then this is in the binary form it is one one, one one.

04:26.920 --> 04:34.060
So in decimal it is 15, 11 or seven is 15.

04:34.060 --> 04:36.850
So it is not like addition or subtraction directly.

04:36.850 --> 04:39.130
You look at the value and give the answer.

04:39.160 --> 04:42.900
Unless you perform some bitwise operations, you cannot get the answer.

04:42.910 --> 04:47.380
If you have some practice on this one, then you may be able to directly give the answer by looking

04:47.380 --> 04:48.010
at them.

04:48.040 --> 04:54.250
Now, next, let us see what is the result of XOR this XOR operation I will take.

04:54.550 --> 04:57.790
Both are same zero, both are same zero.

04:57.820 --> 04:59.440
These two are different one.

04:59.440 --> 05:01.060
These two are different one.

05:01.060 --> 05:03.850
Then leading all are zeros.

05:03.850 --> 05:05.800
So this is 12.

05:05.800 --> 05:07.690
Rather it is two in decimal form.

05:07.690 --> 05:12.790
This is two and see this is one, two, four, eight, eight plus four as well.

05:13.150 --> 05:14.560
So the answer is 12.

05:14.560 --> 05:23.290
Here, let us look at not I will take a character type variable X with value five and also one variable

05:23.290 --> 05:27.130
Y character takes just one byte in C++.

05:27.130 --> 05:35.020
So this X in the binary form it will be five is 101 and remaining all bets are zeros.

05:36.380 --> 05:38.840
So this is the binary form of five.

05:39.170 --> 05:45.320
Then if I say y assign not of x, then let us see what happens.

05:45.740 --> 05:50.180
Not means every binary, but it will change its state.

05:50.180 --> 05:51.650
That is zero will become one.

05:51.650 --> 05:53.000
One will become zero.

05:53.120 --> 05:56.920
So this becomes a zero and one and zero.

05:56.930 --> 05:59.780
Then all these are ones.

06:01.180 --> 06:06.280
So this is the complement or the note of x.

06:07.150 --> 06:10.210
Now as this bit is a sign word.

06:11.110 --> 06:13.170
So this is one now.

06:13.180 --> 06:16.120
So it means the number is negative.

06:18.050 --> 06:22.370
The negative numbers in C++ are represented in TOS complement form.

06:23.030 --> 06:27.830
If you want to get the positive value of it, then again you have to take TOS complement and you get

06:27.830 --> 06:28.820
the positive value.

06:29.060 --> 06:30.800
So it is a negative number.

06:30.950 --> 06:33.920
Then what is the value in decimal form?

06:33.920 --> 06:37.990
So to know the value in decimal form I should convert it to two complement.

06:37.990 --> 06:39.350
Then I can get the value.

06:39.350 --> 06:41.900
So let us convert into twos complement.

06:46.090 --> 06:48.820
First convert zeros to once and once to zero.

06:48.820 --> 06:52.710
So this is 00000101.

06:52.720 --> 06:55.180
Then add one to this number.

06:55.480 --> 06:58.720
So one plus one is two.

06:58.720 --> 06:59.320
That is zero.

06:59.320 --> 07:05.080
Carry one and this is one and this is one, then 00000.

07:05.560 --> 07:08.680
Then how much does this six.

07:09.860 --> 07:13.070
So this is a negative six.

07:14.680 --> 07:18.160
So not off fivers minus six.

07:18.190 --> 07:21.880
Now, before going further, let us put a question here.

07:21.910 --> 07:23.530
Where do you need this?

07:23.680 --> 07:29.830
If you are developing devices, drivers, or if you are developing core system programs or system applications

07:29.830 --> 07:34.450
or tools, then there you may be working more closer to electronics.

07:34.450 --> 07:36.910
And these are the operations in electronics.

07:36.910 --> 07:41.410
So your C program, also, you want it to perform those type of operations.

07:41.950 --> 07:45.490
Your logic itself is defined in terms of bit operations.

07:45.490 --> 07:50.050
So then you can use this operators there for adding your procedures.

07:50.840 --> 07:56.600
So if you are writing hardware based or device drivers there, it is useful.

07:56.990 --> 08:00.480
Now, let me show what does it mean by lift shift and write shift?

08:00.500 --> 08:03.860
I will take the value of X as a five and y.

08:03.860 --> 08:07.040
So in binary form five is 101.

08:07.040 --> 08:11.390
So leading all 16 bits as zeros remaining, the bits are zeros.

08:11.390 --> 08:13.220
So I will just add eight here.

08:13.820 --> 08:15.710
I will write just eight bits here.

08:16.220 --> 08:24.380
This is x left to shift two by one and I want to show the result and y then this bit is shifted here.

08:24.380 --> 08:26.510
So this is one and this is shifted here zero.

08:26.510 --> 08:30.650
This is shifted here one and all these bits are shifted to the side.

08:30.650 --> 08:32.450
So remaining five bits.

08:34.790 --> 08:35.960
I shifted the side.

08:35.990 --> 08:39.320
This place is vacant now, so here zero is inserted.

08:39.350 --> 08:40.640
Now, how much is this?

08:40.760 --> 08:43.040
This is one, two, four, eight.

08:43.050 --> 08:44.870
So this is eight plus two.

08:44.900 --> 08:46.220
This is ten.

08:46.400 --> 08:52.280
So actually, what has happened is when you shift all these bids on the left hand side by one space,

08:52.280 --> 08:54.980
then this five will get multiplied by two.

08:55.670 --> 09:00.590
If you move them by two space, then it will get multiplied by four.

09:01.930 --> 09:08.170
So it is just like whatever the value of X is, this will get multiplied by two power.

09:08.200 --> 09:11.780
Whatever the number you write here, whatever the number you write.

09:11.800 --> 09:19.360
So if I say x left shift I then this will be X into two part II.

09:20.350 --> 09:22.530
So if it is one, then it is multiplied by two.

09:22.540 --> 09:26.410
If I is a two, then x will be multiplied by four and so on.

09:26.880 --> 09:36.430
Now similarly, if right shift is used, then if I say x right shift by I, then x will get divided

09:36.430 --> 09:37.540
by two, right?

09:38.260 --> 09:42.540
So if five five will get half, that is a two integer division.

09:42.550 --> 09:44.290
If it is a ten, it will become five.

09:44.290 --> 09:45.610
So the number will become half.

09:45.610 --> 09:51.640
If you write shift by one place, if it is done by two place, then it is divided by quarter.

09:51.640 --> 09:52.330
That is four.

09:52.330 --> 09:55.180
It will convert into quarter, that is divided by four.

09:56.050 --> 10:00.460
But one thing you remember here sign but is not included.

10:01.510 --> 10:02.800
The most significant bet.

10:02.800 --> 10:04.960
If the number is negative, it remains negative.

10:04.960 --> 10:11.110
Only if it is positive, remain positive only sine but is not a disturbed and left and right set of

10:11.110 --> 10:11.860
reactions.

10:12.340 --> 10:15.400
Let us see this practically by writing some program.

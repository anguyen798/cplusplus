WEBVTT

0
00:00.220 --> 00:07.800
In this video let us talk about functions, function is a piece of program code which performs a specific

1
00:07.800 --> 00:16.440
task, maybe a small task but it performs it completely, it takes some input as parameters and return the result 

2
00:16.470 --> 00:24.960
as a return value. functions are useful for procedural programming or modular programming.

3
00:25.140 --> 00:30.270
If you write a function then we can reuse it in the program, multiple times we can use it and even

4
00:30.270 --> 00:37.260
we can use it in other programs and also we can share it with other programmers and the collection of functions

5
00:37.290 --> 00:44.490
we call it as a library like C C++ languages provides a lot of build-in functions in their library and

6
00:44.490 --> 00:48.360
we commonly used them for making the programming easy.

7
00:48.360 --> 00:53.160
Let us see how we write the functions and what is the idea behind writing functions.

8
00:53.160 --> 00:59.610
see every c++ program must have a main functions so I'm writing void main even we can write int main

9
00:59.610 --> 01:02.390
also here but I'm writing void main.

10
01:02.400 --> 01:07.360
So we know that this is the entry point of our program and a work program executed from here only.

11
01:07.640 --> 01:09.340
And what ever we want.

12
01:09.340 --> 01:10.310
I write down the code here.

13
01:10.320 --> 01:12.880
Suppose I'm writing the code here.

14
01:13.320 --> 01:20.400
Now just listen this carefully if I have a very big program I have some 10000 lines of code.

15
01:20.400 --> 01:26.280
Then everything I'm writing inside main function only, then if you have a single function then this style

16
01:26.280 --> 01:29.310
of programming is called monolithic programming. And

17
01:31.110 --> 01:35.160
If you write the program like this, let us see what the problems we face.

18
01:35.160 --> 01:40.730
First problem if there is a error in a single line then it's an error in the entire program.

19
01:40.730 --> 01:42.980
Or entire main function.

20
01:43.050 --> 01:49.050
Second problem, 10000 line of code I cannot finish it in one hour or one day it might take a few

21
01:49.050 --> 01:53.280
days and through out the time I should remember everything.

22
01:53.280 --> 01:56.770
Then only I can make changes or write new lines in the program.

23
01:57.630 --> 01:59.850
So memorizing the whole program.

24
02:00.100 --> 02:00.980
Then the third thing.

25
02:00.990 --> 02:05.490
How many people can write this one single main function with everything.

26
02:05.490 --> 02:06.840
10000 lines here.

27
02:06.840 --> 02:08.460
Only one person can write.

28
02:08.460 --> 02:13.670
We cannot make it as a team work and more than one people are working on the same main function.

29
02:13.680 --> 02:14.750
Not possible.

30
02:14.940 --> 02:19.250
So work cannot be distributed in a team.

31
02:19.440 --> 02:21.080
Now the  fourth problem.

32
02:21.090 --> 02:24.060
when this program becomes very big.

33
02:24.060 --> 02:26.180
It may fit in some computer memories.

34
02:26.190 --> 02:28.950
It may not fit some in some of the memories.

35
02:28.950 --> 02:29.870
It depends.

36
02:29.970 --> 02:35.310
Depends on the size and depends on the hardware contribution of the computer on which you are running.

37
02:35.310 --> 02:42.810
So these are a few problems due to monolithic programming, monolithic means everything is a single unit.

38
02:42.810 --> 02:44.910
The complete program as a single unit.

39
02:45.000 --> 02:46.550
So what we prefer is.

40
02:46.590 --> 02:53.460
Let us break the program into pieces, manageable and small pieces and re-usable pieces.

41
02:53.790 --> 02:59.210
Then the benefit is I can develop it piece wise so I can concentrate on one piece at a time.

42
02:59.220 --> 03:01.510
One piece of code at a time.

43
03:01.530 --> 03:07.080
Second thing the pieces can be distributed among the team of programmer and they can develop some set

44
03:07.080 --> 03:10.700
of pieces and we can collect them together and make it as a single program.

45
03:11.890 --> 03:18.610
And definitely the main will be integrating all of them directly or indirectly then one more thing,

46
03:18.630 --> 03:20.050
when we are on some computer.

47
03:20.070 --> 03:22.890
Then we can load and unload the pieces that we require.

48
03:22.920 --> 03:29.250
So we don't have to have a very large sized memory on the computer in which we are running, solve the problems

49
03:29.250 --> 03:29.730
are solved.

50
03:30.030 --> 03:32.460
So this is nothing but modular programming.

51
03:32.460 --> 03:34.190
This can be done using functions.

52
03:35.280 --> 03:40.110
So let us see how to write a function, first of all function should have a name.

53
03:40.110 --> 03:45.320
Function name, function name must be there.

54
03:45.930 --> 03:54.280
Then it should have parameter list or also called as argument list what all

55
03:54.300 --> 04:00.410
the parameters it is taking, then function should have return type.

56
04:00.590 --> 04:06.180
What value it is returning, it should have the data type of that value here.

57
04:06.180 --> 04:13.720
So functions are identified by their name and this becomes input to the function.

58
04:13.820 --> 04:23.400
And this is the output of a function, A function can take 0 or more input means it may not take any

59
04:23.400 --> 04:23.730
input

60
04:23.730 --> 04:27.260
Also, it depends how you are writing a function what purpose you are writing.

61
04:27.270 --> 04:36.660
Function, then it may return or may not return a value but it can return at most one value just

62
04:36.660 --> 04:43.320
one value a function cannot return multiple values but it can take multiple values as input output

63
04:43.320 --> 04:49.290
should be only one, if the function is not returning any value then the return type should be void

64
04:50.390 --> 04:53.460
now one more thing, how the function name should be.

65
04:53.460 --> 04:58.480
The rules for giving function names are the same as the rules of giving variable name.

66
04:58.490 --> 05:00.690
How you give variable name same way.

67
05:00.690 --> 05:05.110
Same rules you should follow for giving function name also.

68
05:05.100 --> 05:10.950
Now let us write one example function and use it in our main function.

69
05:10.980 --> 05:11.390
I will write 

70
05:11.400 --> 05:12.930
main function

71
05:15.380 --> 05:23.630
now here I will write one function, void display the function name is  display and it is not taking

72
05:23.630 --> 05:25.710
any parameters so I can leave it empty.

73
05:25.710 --> 05:26.680
this is the function name.

74
05:26.690 --> 05:27.800
This is parameter list.

75
05:27.800 --> 05:28.660
Nothing is there.

76
05:28.720 --> 05:31.320
Return type is not returning anything, then

77
05:31.460 --> 05:37.240
Inside this I would write Cout hello.

78
05:37.250 --> 05:41.060
just This is a wishing message. now from here.

79
05:41.060 --> 05:47.470
This is the way we call a function display, so the function will be called so inside the main function

80
05:47.480 --> 05:50.210
I'm not doing anything just calling the main function.

81
05:50.210 --> 05:52.460
So let us see how it runs.

82
05:52.570 --> 05:58.280
See when the main function starts it will come to this line so it will go here and execute this and

83
05:58.280 --> 06:00.860
return back and continue the main function.

84
06:01.250 --> 06:04.280
So if I have a few lines here and after this also.

85
06:04.280 --> 06:09.590
So the first line and the second line, and the third line and fourth line so after first line it will go to second

86
06:09.590 --> 06:10.500
so second line

87
06:10.500 --> 06:15.450
It will execute this return back and it will continue with third and fourth line.

88
06:15.480 --> 06:22.220
Now one important thing that inside the functions avoid user interaction.

89
06:22.220 --> 06:24.590
That is a cin and cout.

90
06:24.590 --> 06:26.540
It's a bad function.

91
06:26.540 --> 06:29.630
You should avoid using cin cout inside the function.

92
06:29.630 --> 06:31.820
So the function should not interact.

93
06:31.880 --> 06:34.070
So the idea behind that I would tell you.

94
06:34.070 --> 06:41.420
Suppose there is an organization so main is a manager or the owner of a business and this is his employee

95
06:41.510 --> 06:42.700
this plays as his employee.

96
06:42.800 --> 06:48.470
So who called to the employee, manager has called the employee here for some work.

97
06:48.500 --> 06:52.280
So who should contact or who should communicate with the clients.

98
06:52.290 --> 06:58.710
of a business, the customers of a business, manager or the owner should interact, so cin cout

99
06:58.760 --> 07:01.170
communication with the client.

100
07:01.280 --> 07:05.900
So communication client is whose client here, user.  so through main functional function only the communication with

101
07:05.900 --> 07:07.260
the user should be done.

102
07:07.280 --> 07:13.730
All other functions must be just supporting the main function so they should not have cin cout in them.

103
07:13.730 --> 07:18.970
This is a good practice so you should avoid it, but for explanation purpose I may be writing cin cout

104
07:18.980 --> 07:25.040
OK, just for explanation purposes, but when you really develop the application don't have interactivity

105
07:25.040 --> 07:32.740
inside the functions, let me write a few more functions and show you. i will write a  function for adding t2o numbers

106
07:32.900 --> 07:39.140
simple functions so add is the name of a function, it has to take two parameters you can give any

107
07:39.140 --> 07:46.310
data type here but to make it simple for understanding I'm always taking integer types so two integer

108
07:46.310 --> 07:51.370
values I have given an names as X and y now after adding themit is going to return the result.

109
07:51.420 --> 07:57.410
The result is going to be of typing int only, so return type of a function is also integer.

110
07:57.590 --> 08:00.910
Now here what I would do is I will declare one variable Z.

111
08:01.070 --> 08:03.720
Then I will say z assign  X plus Y.

112
08:03.740 --> 08:08.370
I'm just making it a little lenghty then say  return Z.

113
08:09.980 --> 08:15.840
So the value of x and y is that and that as it is stored in Z and Z the value is returned.

114
08:15.860 --> 08:17.770
let us write the main function and use it.

115
08:17.780 --> 08:18.860
So I will write.

116
08:18.860 --> 08:28.950
Void main, just to seperate them I will draw a line here I will have two variable a as value 10

117
08:29.450 --> 08:36.680
and b value as a 15 then also I will have some variable c. then I will say add i will send

118
08:36.680 --> 08:44.720
these two values A and B and whatever the value is returning this would be done value z.

119
08:44.720 --> 08:53.540
I will take it in C, then  here I will say scout sum is

120
08:53.600 --> 08:55.940
C that's it.

121
08:55.960 --> 08:58.890
So this is a main function which is calling this function.

122
08:59.970 --> 09:01.680
Let us see how this works.

123
09:01.720 --> 09:06.910
Inside the main memory so I will draw diagram of the main memory I will show  you, see we know that

124
09:06.910 --> 09:14.470
the memory is divided in three sections, that is code section and the stock and heap so

125
09:22.900 --> 09:25.660
this wording is very very important for you.

126
09:25.690 --> 09:28.780
Watch it and remember it for always.

127
09:28.810 --> 09:38.430
See there are two pieces of code so Code section will have the code add function as well as main function.

128
09:38.440 --> 09:44.130
So the machine code will be also in two pieces, we wrote  it into 2 pieces that will also in 2 pieces

129
09:44.920 --> 09:51.820
see mostly people believe that the machine code of this add function would be copied at this place, no machine

130
09:51.820 --> 09:54.660
code will be separate, 2 different pieces will be there.

131
09:55.080 --> 10:00.340
Now program we are running  so this is there inside this code section.

132
10:01.000 --> 10:03.650
So the program is loaded in the code section.

133
10:03.670 --> 10:06.190
Now let us see the working main function start.

134
10:06.210 --> 10:16.690
The first line sees that it needs variables for ABC of type Integer so memory for A B and C 

135
10:16.700 --> 10:17.450
will be allocated

136
10:17.470 --> 10:19.460
So these bytes are belonging

137
10:19.460 --> 10:25.240
The main function, and this we called it as activation record of Main function and A's having value 

138
10:25.270 --> 10:31.930
10 and B's having value 15, see is empty and that is having some garbage value now.

139
10:31.990 --> 10:33.690
Next there is a call to function add.

140
10:33.780 --> 10:37.300
So the control goes to add the moment the function is called

141
10:37.330 --> 10:43.750
Then for this function also activation record is created inside the stock containing all the variables

142
10:43.750 --> 10:44.540
used here.

143
10:44.650 --> 10:45.820
X Y and Z.

144
10:46.360 --> 10:54.380
So X and Y and Z three blocks are created for three variables.

145
10:54.480 --> 11:00.210
From here what is passed, a and b, so a value goes into x and b value goes into y.

146
11:00.280 --> 11:05.570
So this 10 goes into this one and 15 goes here.

147
11:05.590 --> 11:07.630
Now next line this is already done.

148
11:07.660 --> 11:08.740
This is completed right.

149
11:08.770 --> 11:10.420
So now Z assign X plus Y.

150
11:10.450 --> 11:14.040
So these two values are added and 25 is stored here.

151
11:14.910 --> 11:23.320
Now return z, this line is over, return  Z means this value is copied in C because here if you see this written

152
11:23.350 --> 11:29.970
value will go into C here whatever the function is returning it will go into c  so C will contain

153
11:29.990 --> 11:31.200
25.

154
11:31.250 --> 11:36.910
And once the function ends it reaches here once the function ends it's a memory inside.

155
11:36.910 --> 11:40.830
The stock will be removed so its activation record is deleted.

156
11:41.200 --> 11:47.260
So this means we understand that whenever the function is callled the memory for all the variables using

157
11:47.260 --> 11:51.270
that function is created inside the stack, and when the function ends

158
11:51.580 --> 11:59.350
All that memory will be cleared automatically, and one more important thing if this function had located

159
11:59.350 --> 12:03.000
some memory in heap that will not be deallocated automatically.

160
12:03.010 --> 12:09.520
Function should release it by saying delete, so new if it says and  get the memory in heap it must

161
12:09.520 --> 12:10.120
be deleted.

162
12:10.420 --> 12:12.250
So anyway back to this one.

163
12:12.250 --> 12:15.790
So the function ends now the control come back here.

164
12:15.880 --> 12:20.980
Now still main function memory variables are there inside the main memory inside the stack now cout

165
12:20.980 --> 12:22.710
sum c

166
12:22.750 --> 12:23.550
So here.

167
12:23.650 --> 12:25.760
Twenty five is displayed and

168
12:25.920 --> 12:32.830
Function main ends, once the function main ends its activation record or the memory for all those

169
12:32.830 --> 12:35.010
variables will also be cleared.

170
12:38.030 --> 12:43.110
So this is how the working the function and we will write many functions.

171
12:43.100 --> 12:48.620
So practically I will show you some functions and I'll also I'll give you some challenges for writing

172
12:48.620 --> 12:49.510
some functions.
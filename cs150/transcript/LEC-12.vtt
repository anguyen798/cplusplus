WEBVTT

00:00:00.000 --> 00:00:10.000
Hello everyone, welcome to lecture 12. I'm Steve Gilbert and today we're going to look at processing disk files.

00:00:10.000 --> 00:00:13.000
Let's start with a little bit of review though.

00:00:13.000 --> 00:00:18.000
So first I want to look at streams and data loops.

00:00:18.000 --> 00:00:26.000
So the stream classes that we're going to use are IStream and OStream.

00:00:26.000 --> 00:00:35.000
IStream is the input stream class. It's a class that knows how to read data and bring it into your program.

00:00:35.000 --> 00:00:43.000
The OStream class is an output stream class. It knows how to read/write data and send it out of your program.

00:00:43.000 --> 00:00:54.000
When your program starts up, it automatically creates several global standard stream objects.

00:00:54.000 --> 00:01:02.000
CIN for input, COUT for output, and CERR for sending out error messages.

00:01:02.000 --> 00:01:14.000
These are automatically connected to your operating system's standard streams called StandardIN, StandardOUT, and StandardERR.

00:01:14.000 --> 00:01:25.000
By the way, Java does exactly the same thing. StandardIN is connected to a scanner object when you create it.

00:01:25.000 --> 00:01:32.000
System.OUT is connected to the StandardOUTput just like COUT is.

00:01:32.000 --> 00:01:41.000
And System.ERR is connected to StandardOUTput just like CERR is in Java.

00:01:41.000 --> 00:01:46.000
Now we can use these streams with a special kind of loop called a data loop.

00:01:46.000 --> 00:01:55.000
A data loop stops not when we reach a counter, not when we reach a limit, but when the source is out of data.

00:01:55.000 --> 00:01:59.000
And there are three different ways to read from a stream.

00:01:59.000 --> 00:02:07.000
We can read a character by character, which is what we did when we wrote our filter programs in the last lecture.

00:02:07.000 --> 00:02:12.000
So while CIN, GET CH, COUT, PUT CH.

00:02:12.000 --> 00:02:21.000
We can also use the string function called GETLINE to read an entire line of input.

00:02:21.000 --> 00:02:29.000
So notice here I'm saying while GETLINE, I'm using any kind of input stream, IN, LINE,

00:02:29.000 --> 00:02:35.000
and this will again, when it's out of data, it will return false, and I'm printing out the line.

00:02:35.000 --> 00:02:40.000
When you read this line, it will strip the new line character from the end,

00:02:40.000 --> 00:02:47.000
so I needed to add it here if I wanted my output to look the same as the input.

00:02:47.000 --> 00:02:51.000
And finally I can read token by token.

00:02:51.000 --> 00:02:56.000
So I can do while IN, N, COUT, N.

00:02:56.000 --> 00:03:06.000
And this will not only read whatever kind IN is, but it will convert the characters into the type of IN.

00:03:06.000 --> 00:03:11.000
So if I had a file full of integers, I could process it using this.

00:03:11.000 --> 00:03:13.000
Of course, this is slightly different.

00:03:13.000 --> 00:03:18.000
GET and GETLINE will only end when they run out of data.

00:03:18.000 --> 00:03:23.000
When I have a formatted input like this, or token-oriented input,

00:03:23.000 --> 00:03:30.000
it could end when there is something that is not an integer, for instance, in the stream.

00:03:30.000 --> 00:03:34.000
So we're going to look at a function that takes a stream as input,

00:03:34.000 --> 00:03:45.000
and we're going to use a data loop with the first exercise today called SUM EVENS.

00:03:45.000 --> 00:03:49.000
So make sure you've gone to week 3.

00:03:49.000 --> 00:03:54.000
On week 3, make sure you've gone to the files tab over here.

00:03:54.000 --> 00:03:56.000
Click the lecture exercises.

00:03:56.000 --> 00:03:59.000
Click the link for the starter code.

00:03:59.000 --> 00:04:03.000
Go ahead and make a copy of this, change the name on it,

00:04:03.000 --> 00:04:09.000
and we're ready to go with exercise A on data loops.

00:04:09.000 --> 00:04:18.000
So we're going to write the function SUMEVEN that adds all the even numbers inside its ISTREAM argument.

00:04:18.000 --> 00:04:26.000
So go ahead and open a shell over here on folder A in 12,

00:04:26.000 --> 00:04:39.000
and open up evensummer.cpp.

00:04:39.000 --> 00:04:43.000
So this function is going to return an int.

00:04:43.000 --> 00:04:46.000
Let's see what it was named again.

00:04:46.000 --> 00:04:48.000
It was named SUMEVENS.

00:04:48.000 --> 00:04:54.000
It's going to take an ISTREAM argument, so it's going to read from a stream.

00:04:54.000 --> 00:05:03.000
So SUMEVENS ISTREAM, we'll just call it int.

00:05:03.000 --> 00:05:11.000
And we'll do int sum is zero and return sum.

00:05:11.000 --> 00:05:17.000
Unfortunately when we try and compile this, when we just do make down here,

00:05:17.000 --> 00:05:22.000
you'll see we get a whole bunch of errors.

00:05:22.000 --> 00:05:30.000
And the problem is that we are passing the wrong kind of argument.

00:05:30.000 --> 00:05:38.000
So when you pass a stream, it's a library type, so you cannot pass it by value.

00:05:38.000 --> 00:05:42.000
So we're going to pass it by reference.

00:05:42.000 --> 00:05:47.000
And so now when we do make, the code compiles.

00:05:47.000 --> 00:05:51.000
So you cannot pass streams by value.

00:05:51.000 --> 00:05:55.000
You cannot pass streams by value.

00:05:55.000 --> 00:06:02.000
Now for our data loop, we want to read an integer from this stream.

00:06:02.000 --> 00:06:09.000
So we're going to have int n. We're going to say while int n.

00:06:09.000 --> 00:06:19.000
So while we read the integer n from int, if n remainder 2 equals zero,

00:06:19.000 --> 00:06:24.000
it's an even number, then we're going to add it to our sum.

00:06:24.000 --> 00:06:30.000
So sum plus equals n.

00:06:30.000 --> 00:06:40.000
Okay, so let's try that.

00:06:40.000 --> 00:06:44.000
Make test.

00:06:44.000 --> 00:06:47.000
And here we've added some integers here.

00:06:47.000 --> 00:06:51.000
One, two, three, four, one, two, five, seven.

00:06:51.000 --> 00:06:53.000
No even numbers here.

00:06:53.000 --> 00:06:55.000
All even numbers here.

00:06:55.000 --> 00:06:57.000
No numbers here.

00:06:57.000 --> 00:06:58.000
And so forth.

00:06:58.000 --> 00:07:01.000
So notice we're not doing this with a string.

00:07:01.000 --> 00:07:04.000
We're doing it with a stream.

00:07:04.000 --> 00:07:06.000
We're doing it with a stream.

00:07:06.000 --> 00:07:10.000
Remember all stream input is character input.

00:07:10.000 --> 00:07:21.000
Character input.

00:07:21.000 --> 00:07:26.000
So we talked about filter programs in the last lecture, in lecture 11.

00:07:26.000 --> 00:07:32.000
So filter programs read from standard input, and they write to standard output.

00:07:32.000 --> 00:07:37.000
State filters, like the one we did, look for changes in input.

00:07:37.000 --> 00:07:42.000
So CECO changed the state of its printed flag.

00:07:42.000 --> 00:07:47.000
So the printing Boolean flag was used to monitor the stream state

00:07:47.000 --> 00:07:51.000
when we did that with Alice in Wonderland.

00:07:51.000 --> 00:07:56.000
Process filters modify their stream's contents.

00:07:56.000 --> 00:08:02.000
So here, for instance, is the toUpper filter that I showed you in the last lecture.

00:08:02.000 --> 00:08:06.000
Well, CN getCH, C output, toUpperCH.

00:08:06.000 --> 00:08:10.000
So we're processing the data as we go through.

00:08:10.000 --> 00:08:20.000
So we're going to do that with an exercise just to get a little bit more used to stream input and output.

00:08:20.000 --> 00:08:26.000
We're going to write a 150 encryption library.

00:08:26.000 --> 00:08:31.000
So let's look at the details over there in our handout.

00:08:31.000 --> 00:08:36.000
So an encryption program scrambles the bytes in a file

00:08:36.000 --> 00:08:44.000
so that the file is unreadable except to those who know the decryption method and the secret keyword.

00:08:44.000 --> 00:08:50.000
Now, we're going to ignore 2,000 years of progress in the field of encryption,

00:08:50.000 --> 00:08:54.000
and we're going to use a method that was familiar to Julius Caesar.

00:08:54.000 --> 00:09:01.000
He simply replaced his A's with a D, B's with an E, and so forth.

00:09:01.000 --> 00:09:04.000
And this is called the Caesar cipher.

00:09:04.000 --> 00:09:13.000
And so the idea with a Caesar cipher, or any cipher, is you get input, which is plain text,

00:09:13.000 --> 00:09:18.000
and then you get output, which is called cipher text.

00:09:18.000 --> 00:09:20.000
Now, notice a couple things about it.

00:09:20.000 --> 00:09:25.000
We are only ciphering the things that are characters.

00:09:25.000 --> 00:09:34.000
We are not ciphering the spaces, and we're not ciphering any punctuation.

00:09:34.000 --> 00:09:37.000
We're only ciphering the characters.

00:09:37.000 --> 00:09:44.000
Now, with encryption, if we pass in encryption text, we should get back the plain text.

00:09:44.000 --> 00:09:51.000
So let's go ahead and look at our lib function in the starter code over here in B.

00:09:51.000 --> 00:09:56.000
Let's close Even Summer, close these shells we've opened already,

00:09:56.000 --> 00:10:02.000
go down to B, and you can see I have a folder called enclib.

00:10:02.000 --> 00:10:07.000
So let's open a shell on that, on enclib.

00:10:07.000 --> 00:10:14.000
And we're going to look at encrypt the header file.

00:10:14.000 --> 00:10:21.000
And you can see I've already put inside here the two functions we're going to write in the namespace inc.

00:10:21.000 --> 00:10:24.000
I've already documented them.

00:10:24.000 --> 00:10:31.000
And we are simply going to implement those two functions over here.

00:10:31.000 --> 00:10:38.000
So go ahead and put your name on the top there.

00:10:38.000 --> 00:10:49.000
And then let's grab from inc.h, let's grab the namespace,

00:10:49.000 --> 00:10:53.000
and the prototype, and pop it over here.

00:10:53.000 --> 00:10:59.000
I'm going to leave the documentation over here because it makes it a little bit easier.

00:10:59.000 --> 00:11:06.000
Ok, so we have one function that will take plain text and turn it to cipher text,

00:11:06.000 --> 00:11:11.000
and one function that will take cipher text and turn it to plain text.

00:11:11.000 --> 00:11:16.000
Notice each of these are going to read from input and write to output.

00:11:16.000 --> 00:11:19.000
So both of them are going to use a data loop.

00:11:19.000 --> 00:11:35.000
So char ch while in.get, notice we're not using cn here, ch, out.

00:11:35.000 --> 00:11:38.000
We're not using cout either.

00:11:38.000 --> 00:11:42.000
Put ch.

00:11:42.000 --> 00:11:50.000
Let's put the other one for the plain text one.

00:11:50.000 --> 00:11:56.000
So now we've got our stubs here, our things that read from input, write to output.

00:11:56.000 --> 00:12:00.000
We're not using the key here at all.

00:12:00.000 --> 00:12:06.000
And so let's do make test.

00:12:06.000 --> 00:12:14.000
So you can see on this, all of these failed of course because we haven't done any encryption.

00:12:14.000 --> 00:12:20.000
So I am getting, so notice I'm putting out exactly what I got in.

00:12:20.000 --> 00:12:26.000
So when I get in attack at dawn, I expect to get this as output.

00:12:26.000 --> 00:12:32.000
When I get in how now brown cow, I expect to get this as output.

00:12:32.000 --> 00:12:44.000
When I decrypt attack this, I expect to get attack at dawn and how now brown cow and I love cs150.

00:12:44.000 --> 00:12:49.000
So let's go and look at each of those characters.

00:12:49.000 --> 00:12:58.000
What we're going to do is we're going to add this number, shifting the characters rightward.

00:12:58.000 --> 00:13:04.000
So if it's an A and the key was one, it's going to become B.

00:13:04.000 --> 00:13:13.000
So we could simply try that by saying key.

00:13:13.000 --> 00:13:22.000
And to decrypt it, we're going to do the same thing.

00:13:22.000 --> 00:13:28.000
Okay, let's see how that works. That's pretty simplified.

00:13:28.000 --> 00:13:32.000
But let's see if it in fact works.

00:13:32.000 --> 00:13:39.000
It didn't look like it worked anywhere because look at, we are almost got that one right.

00:13:39.000 --> 00:13:44.000
But we're encrypting the spaces.

00:13:44.000 --> 00:13:54.000
So notice that that means that when we print the data out, we need to say,

00:13:54.000 --> 00:14:17.000
if, and we're going to use from the CC type up here, we're going to use the header, we're going to use the function if is alpha.

00:14:17.000 --> 00:14:19.000
And we could do it manually, right?

00:14:19.000 --> 00:14:24.000
We could say if ch, I mean I could do it like this.

00:14:24.000 --> 00:14:34.000
If ch is greater or equal to A and ch is less than or equal to Z.

00:14:34.000 --> 00:14:43.000
Or ch is greater or equal to A and ch is less than or equal to Z.

00:14:43.000 --> 00:14:52.000
That would be the same as saying if is alpha ch.

00:14:52.000 --> 00:14:55.000
Which is probably a little bit easier to read.

00:14:55.000 --> 00:15:01.000
So if it's alpha, we're going to print the thing with the key.

00:15:01.000 --> 00:15:09.000
Else, we're going to output ch.

00:15:09.000 --> 00:15:13.000
We're going to do the same thing up here.

00:15:13.000 --> 00:15:14.000
I'll just put it right there.

00:15:14.000 --> 00:15:20.000
If is alpha ch.

00:15:20.000 --> 00:15:21.000
I'll put that.

00:15:21.000 --> 00:15:28.000
Else, I'll put ch plus key.

00:15:28.000 --> 00:15:32.000
OK, let's try it this third time.

00:15:32.000 --> 00:15:40.000
The second time we didn't get any passing. Let's see if we get any passing this time.

00:15:40.000 --> 00:15:42.000
Ah, I got one passing.

00:15:42.000 --> 00:15:45.000
I got how now brown cow.

00:15:45.000 --> 00:15:55.000
How now brown cow.

00:15:55.000 --> 00:16:03.000
That one is still not working. Let me try that again.

00:16:03.000 --> 00:16:07.000
The first one is still not working at all and I thought we kind of fixed that.

00:16:07.000 --> 00:16:12.000
So let's look. Oh, notice the mistake I made there.

00:16:12.000 --> 00:16:17.000
So if it's not an alpha character, we just want to put it out.

00:16:17.000 --> 00:16:22.000
OK, not with the key.

00:16:22.000 --> 00:16:25.000
OK, let's try it again.

00:16:25.000 --> 00:16:27.000
Now we got two passing.

00:16:27.000 --> 00:16:32.000
So how now brown cow works in both cases.

00:16:32.000 --> 00:16:35.000
This is the encrypted version of it.

00:16:35.000 --> 00:16:40.000
This is the decrypted version of the ciphertext here.

00:16:40.000 --> 00:16:43.000
This doesn't quite work.

00:16:43.000 --> 00:16:45.000
So this is a tackadon.

00:16:45.000 --> 00:16:52.000
So attack seems to work. At seems to work.

00:16:52.000 --> 00:16:57.000
So instead of B here, I have that.

00:16:57.000 --> 00:17:00.000
So our key here is five.

00:17:00.000 --> 00:17:08.000
So if I take W, I should change it to an X for one, Y for two, Z for three.

00:17:08.000 --> 00:17:13.000
Oh, four is going to move me beyond the characters.

00:17:13.000 --> 00:17:21.000
Right. So if I'm at the end of the character, if I'm at the end of the set of characters and I'm moving to the right,

00:17:21.000 --> 00:17:27.000
then I have to add myself around. Right. I have to move it around.

00:17:27.000 --> 00:17:37.000
So that means we're kind of doing a remainder operator, but I need to use a.

00:17:37.000 --> 00:17:40.000
I need to use an actual modulus operator.

00:17:40.000 --> 00:17:48.000
So this looked pretty simple, but it's not actually that simple.

00:17:48.000 --> 00:17:54.000
So we can do it two ways. I'll show you one way where I do three things.

00:17:54.000 --> 00:18:13.000
So is upper. Ch. Else if is lower. Ch.

00:18:13.000 --> 00:18:23.000
OK, for this one, what we're going to do if it's upper, what I'm going to need to do is,

00:18:23.000 --> 00:18:29.000
you know, that's not going to work. Let me pause it for a second. Let me figure out how to get it to work.

00:18:29.000 --> 00:18:35.000
OK, so this is relatively complex. So what I'm going to have to do,

00:18:35.000 --> 00:18:51.000
so I'm going to have to take the ASCII code. If it's uppercase, I'm going to have to subtract it from the A.

00:18:51.000 --> 00:19:06.000
Then I'm going to add the key to it. I'm going to take that remainder 26.

00:19:06.000 --> 00:19:24.000
And then I'm going to add A to it. And we'd have to do exactly the same thing with the lowercase one.

00:19:24.000 --> 00:19:33.000
Except we change it to the lowercase character.

00:19:33.000 --> 00:19:43.000
So let's try that and see if the encryption works.

00:19:43.000 --> 00:19:50.000
So the encryption all works right here. Let me show you why that works.

00:19:50.000 --> 00:19:57.000
So basically with characters, here's what we have in memory.

00:19:57.000 --> 00:20:06.000
We have a whole bunch of ASCII characters and then A, B, C, D, through Z.

00:20:06.000 --> 00:20:17.000
Then some more characters and then A, B, C, D, through lowercase C and then some more characters.

00:20:17.000 --> 00:20:32.000
And so A is ASCII 65 and lowercase A is ASCII 97.

00:20:32.000 --> 00:20:39.000
So that's how they're organized. So what we need to do is we need to find the position.

00:20:39.000 --> 00:20:47.000
So if we get an A here, we want the number zero. If we get this A, we also want the number zero.

00:20:47.000 --> 00:20:54.000
So let's use that scheme. So I'm going to call that position.

00:20:54.000 --> 00:21:16.000
So int pos equals, so is upper CH? Then pos is going to be A minus CH.

00:21:16.000 --> 00:21:31.000
If it's not, if it's lower, then pos, now that's actually, we're going to say, int pos equals zero.

00:21:31.000 --> 00:21:56.000
If is upper CH, pos equals A minus CH. Else if is lower CH, pos equals A minus CH.

00:21:56.000 --> 00:22:05.000
So that gives me my position zero, one, two, three, four. I'm going to add the key to pos.

00:22:05.000 --> 00:22:18.000
And I'm going to take it remainder 26. So if we have W and we go beyond 26, it will wrap around to be the character B, which is what we want.

00:22:18.000 --> 00:22:30.000
So I'm going to say pos equals pos plus key remainder 26.

00:22:30.000 --> 00:22:55.000
Now, what do I need to do? If CH is upper, I need to output A plus pos.

00:22:55.000 --> 00:23:09.000
That will give me the character of that position. And in this case, I would need to output A plus pos.

00:23:09.000 --> 00:23:28.000
So we have to know for the difference if it's upper or lower case.

00:23:28.000 --> 00:23:35.000
OK, let's try that one and then we'll put it into the decryption thing.

00:23:35.000 --> 00:23:42.000
The decryption is slightly more complex. OK.

00:23:42.000 --> 00:23:46.000
OK, so all these I got completely wrong.

00:23:46.000 --> 00:23:49.000
And that didn't work at all.

00:23:49.000 --> 00:23:54.000
I'm going to pause again and spend a few seconds thinking about this.

00:23:54.000 --> 00:24:01.000
OK, I saw what I did last time. The mistake was I did the subtraction the wrong way.

00:24:01.000 --> 00:24:08.000
So let's say if is alpha CH.

00:24:08.000 --> 00:24:12.000
So it's got to be an upper case or lower case character.

00:24:12.000 --> 00:24:19.000
Let's find its position inside its respective character set.

00:24:19.000 --> 00:24:27.000
So if pos equals is upper CH.

00:24:27.000 --> 00:24:34.000
So its position is CH minus A.

00:24:34.000 --> 00:24:37.000
Before I wrote that as A minus CH.

00:24:37.000 --> 00:24:43.000
If it's lower case, its position is CH minus lower case A.

00:24:43.000 --> 00:24:49.000
So again, if that's an upper or lower case A, position will be zero.

00:24:49.000 --> 00:24:51.000
Now we want to update the position.

00:24:51.000 --> 00:25:01.000
So pos equals pos plus key.

00:25:01.000 --> 00:25:07.000
Remainder 26 to get us the wraparound effect.

00:25:07.000 --> 00:25:10.000
Now we want to update the characters.

00:25:10.000 --> 00:25:18.000
So CH equals is upper CH.

00:25:18.000 --> 00:25:26.000
If it's upper CH, then CH is uppercase A plus the position.

00:25:26.000 --> 00:25:32.000
And if it's lower case, it's lower case A plus the position.

00:25:32.000 --> 00:25:35.000
Now this is what we do if it's an alphabetical character.

00:25:35.000 --> 00:25:40.000
We encrypt it, all of the characters we print out right here.

00:25:40.000 --> 00:25:44.000
So let's try that.

00:25:44.000 --> 00:25:47.000
Let's do make test.

00:25:47.000 --> 00:25:51.000
And our encryption for the plain text works ok.

00:25:51.000 --> 00:25:58.000
And actually that is a little bit clearer as to what's happening there.

00:25:58.000 --> 00:26:05.000
Let's go ahead and just take this code here.

00:26:05.000 --> 00:26:09.000
And let's think about the decryption.

00:26:09.000 --> 00:26:15.000
Now the decryption, we're subtracting something from the key.

00:26:15.000 --> 00:26:19.000
And so again, we get the position the same.

00:26:19.000 --> 00:26:22.000
We subtract the key the same.

00:26:22.000 --> 00:26:26.000
But now we have a problem in this little piece of code right here.

00:26:26.000 --> 00:26:32.000
Because if this is a negative number, which it will be if we had an A and we shift it left,

00:26:32.000 --> 00:26:41.000
if that is a negative number, the mod 26 doesn't work.

00:26:41.000 --> 00:26:49.000
So what we have to do is add pos plus 26 minus key.

00:26:49.000 --> 00:26:57.000
In other words, we have to shift one whole alphabetical set at the same time.

00:26:57.000 --> 00:27:01.000
And that should do the decryption part ok.

00:27:01.000 --> 00:27:04.000
To turn it into plain text.

00:27:04.000 --> 00:27:07.000
So let's try it.

00:27:07.000 --> 00:27:09.000
Let's do make test.

00:27:09.000 --> 00:27:13.000
And that correctly decrypts our text.

00:27:13.000 --> 00:27:16.000
Attack at dawn is turned into this.

00:27:16.000 --> 00:27:23.000
This is turned into attack at dawn.

00:27:23.000 --> 00:27:28.000
Ok, so that was a little more complex than I expected.

00:27:28.000 --> 00:27:36.000
But a little bit of good review for process filters.

00:27:36.000 --> 00:27:38.000
Ok, so now let's go to our next topic.

00:27:38.000 --> 00:27:45.000
Our next topic is going to be how do I program using disk files.

00:27:45.000 --> 00:27:54.000
So C++ has some classes that explicitly allow you to specify the source to read from a file

00:27:54.000 --> 00:27:58.000
or a sink to write to a file in code.

00:27:58.000 --> 00:28:00.000
So these are in a new header.

00:28:00.000 --> 00:28:02.000
They are not in Iostream.

00:28:02.000 --> 00:28:04.000
It is in the header fstream.

00:28:04.000 --> 00:28:10.000
You probably also need to include Iostream if you want to use cin and cout

00:28:10.000 --> 00:28:13.000
because those are created in the Iostream header.

00:28:13.000 --> 00:28:17.000
So these classes are called ifstream.

00:28:17.000 --> 00:28:19.000
Not istream, ifstream.

00:28:19.000 --> 00:28:22.000
So the f signifying that it is a file.

00:28:22.000 --> 00:28:25.000
That will connect to a file and read data.

00:28:25.000 --> 00:28:31.000
An ofstream, again the f signifying a file, connect to a file and write data.

00:28:31.000 --> 00:28:38.000
Again, if you want to use cin and cout, those are created in Iostream, so include that as well.

00:28:38.000 --> 00:28:44.000
Now, using explicit files involves three steps.

00:28:44.000 --> 00:28:49.000
First, with cin and cout we didn't have to create any objects.

00:28:49.000 --> 00:28:59.000
With the ifstream and ofstream, we need to explicitly create an instance of the stream class we are going to use.

00:28:59.000 --> 00:29:05.000
So again, we didn't need to do these with the standard streams, cin and cout.

00:29:05.000 --> 00:29:09.000
We do need to use it with these explicit file streams.

00:29:09.000 --> 00:29:13.000
Secondly, we need to open the file or create the file.

00:29:13.000 --> 00:29:17.000
We simply associate the stream with a source or sync.

00:29:17.000 --> 00:29:19.000
There are a couple of different methods.

00:29:19.000 --> 00:29:24.000
And then we just read and write from it exactly as if it was cin and cout.

00:29:24.000 --> 00:29:33.000
Finally, in Java you have to be very, very careful to close your stream after you have opened it

00:29:33.000 --> 00:29:35.000
if you create a dist file stream.

00:29:35.000 --> 00:29:38.000
In C++ we don't need to worry about that.

00:29:38.000 --> 00:29:44.000
It will automatically be closed by a destructor, so you don't need to worry about that.

00:29:44.000 --> 00:29:51.000
You may occasionally need to use the close member function, but most of the time you will not.

00:29:51.000 --> 00:29:58.000
So, to create and associate the object, you can do this.

00:29:58.000 --> 00:30:05.000
Here I have created an instance of the stream, just like I create an int or any other variable.

00:30:05.000 --> 00:30:11.000
And then I have called the member function open and told it what text file I want to open.

00:30:11.000 --> 00:30:13.000
Now this is a path.

00:30:13.000 --> 00:30:17.000
This would be in the current working directory.

00:30:17.000 --> 00:30:22.000
If you wanted to open it in a different path, you would pass the entire path inside here

00:30:22.000 --> 00:30:26.000
as a C style string or as a string object.

00:30:26.000 --> 00:30:29.000
You can do the whole thing in one statement though,

00:30:29.000 --> 00:30:34.000
by just passing the path that you want to open to the constructor.

00:30:34.000 --> 00:30:38.000
So here I am using the default constructor and then calling open on it.

00:30:38.000 --> 00:30:41.000
Here I am just using the constructor that opens it.

00:30:41.000 --> 00:30:48.000
You would use exactly the same pattern for OFStream, which would create an output file.

00:30:48.000 --> 00:30:55.000
Now, how do we know if the file was opened correctly or it was created correctly?

00:30:55.000 --> 00:31:02.000
What you have to do, if you can't open it, is you have to check the stream itself.

00:31:02.000 --> 00:31:09.000
If the stream is false, or if its member function fail is true,

00:31:09.000 --> 00:31:12.000
then it didn't open correctly.

00:31:12.000 --> 00:31:14.000
It didn't open correctly.

00:31:14.000 --> 00:31:18.000
And so, what do you do when you can't open it?

00:31:18.000 --> 00:31:22.000
Well, you could use a loop and you could reprompt for the correct file name.

00:31:22.000 --> 00:31:25.000
If you are asking the user to enter a file name.

00:31:25.000 --> 00:31:27.000
Or you could print an error message.

00:31:27.000 --> 00:31:33.000
Now, since this is an error message, we want to use not cout, but we want to use cerror.

00:31:33.000 --> 00:31:40.000
And we could return from the function, return an error code, exit from the program altogether.

00:31:40.000 --> 00:31:46.000
So, let's look at an example that does that.

00:31:46.000 --> 00:31:52.000
And for this, we are going to use the second kind of data loop, a line oriented data loop.

00:31:52.000 --> 00:31:57.000
So, a line oriented data loop reads one line of text at a time.

00:31:57.000 --> 00:32:01.000
It throws away the new line from that line of text.

00:32:01.000 --> 00:32:06.000
Notice that it does not, git line does not return the string.

00:32:06.000 --> 00:32:13.000
Instead, the string is a string passed by reference, which is filled in, in the function.

00:32:13.000 --> 00:32:18.000
What it does return is it returns the stream object itself.

00:32:18.000 --> 00:32:21.000
And we'll use that as the boolean condition.

00:32:21.000 --> 00:32:26.000
While the stream is still good, git align.

00:32:26.000 --> 00:32:33.000
You also, with git line, it's sometimes hard to remember that it's not included in I/O's stream.

00:32:33.000 --> 00:32:37.000
It instead is a function inside the string type.

00:32:37.000 --> 00:32:40.000
So, you have to remember to include string.

00:32:40.000 --> 00:32:44.000
So, our third exercise today is the flip lines problems.

00:32:44.000 --> 00:32:48.000
What we are going to do is open a file or print an error message.

00:32:48.000 --> 00:32:51.000
So, we are going to go over the stuff we did in the last slide.

00:32:51.000 --> 00:32:57.000
And then we are going to reverse the first pair of lines, the second pair, and so forth.

00:32:57.000 --> 00:33:01.000
So, let's go over here.

00:33:01.000 --> 00:33:09.000
Let's look at the exercise.

00:33:09.000 --> 00:33:12.000
So, here we are going to read this file.

00:33:12.000 --> 00:33:15.000
We are going to read the first two lines.

00:33:15.000 --> 00:33:21.000
And then in the output we are going to take the second line and print it first, and the first line and print it second.

00:33:21.000 --> 00:33:23.000
We are going to do that through the whole file.

00:33:23.000 --> 00:33:27.000
Now, notice that a line can be blank, as on the third pair.

00:33:27.000 --> 00:33:32.000
And so we switch to "Beware the Jabberwock" with a blank line.

00:33:32.000 --> 00:33:37.000
And we may have an odd number of lines.

00:33:37.000 --> 00:33:41.000
In that case, only the last line is printed in its original position.

00:33:41.000 --> 00:33:47.000
It's not flipped with an invisible line that would be after it.

00:33:47.000 --> 00:33:49.000
Now, we are going to do two things here.

00:33:49.000 --> 00:33:55.000
We are going to do that, processing the line by line.

00:33:55.000 --> 00:34:00.000
But we are also going to look at the process for opening and checking a file.

00:34:00.000 --> 00:34:06.000
So, we are going to write the function named "flip lines" that accepts the name of the file as its parameter.

00:34:06.000 --> 00:34:10.000
It's not a stream, like the first exercise we did today.

00:34:10.000 --> 00:34:18.000
And it's going to open and write to the console the same file's contents with the lines switched, like I just said.

00:34:18.000 --> 00:34:29.000
If the file cannot be opened, then "cannot open filename.txt" is printed to "Sierra" with "filename.txt" replaced with the actual name.

00:34:29.000 --> 00:34:31.000
So, let's do that.

00:34:31.000 --> 00:34:34.000
OK, this is in C.

00:34:34.000 --> 00:34:38.000
So, we are going to do "flip lines".

00:34:38.000 --> 00:34:46.000
So, put our name on it.

00:34:46.000 --> 00:34:52.000
And the function is named "flip lines".

00:34:52.000 --> 00:35:00.000
It's not going to return anything, so it's going to be a void function.

00:35:00.000 --> 00:35:07.000
And it's going to take a string for the filename.

00:35:07.000 --> 00:35:09.000
So, there's our stub.

00:35:09.000 --> 00:35:14.000
Let's go ahead and open a terminal on C.

00:35:14.000 --> 00:35:17.000
And simply do "make" to make sure the stub works.

00:35:17.000 --> 00:35:22.000
Yes, it works. So, it complies.

00:35:22.000 --> 00:35:28.000
So, step one. We need to create an input stream on filename.

00:35:28.000 --> 00:35:35.000
So, "if stream in" and we'll pass in "fname".

00:35:35.000 --> 00:35:37.000
Let me do it. So, this is the original name.

00:35:37.000 --> 00:35:41.000
So, "in open fname".

00:35:41.000 --> 00:35:43.000
So, that's perfectly OK.

00:35:43.000 --> 00:35:45.000
It's kind of a lot of extra work, though.

00:35:45.000 --> 00:35:47.000
So, let's do this.

00:35:47.000 --> 00:35:52.000
"if stream in fname".

00:35:52.000 --> 00:35:55.000
So, that's "create" and "open" at the same time.

00:35:55.000 --> 00:35:59.000
And I'll comment out these first two lines.

00:35:59.000 --> 00:36:02.000
Now, we need to make sure if it opened.

00:36:02.000 --> 00:36:05.000
So, "if in failed" to open.

00:36:05.000 --> 00:36:08.000
"if in fail".

00:36:08.000 --> 00:36:15.000
What we're going to do is say "sr".

00:36:15.000 --> 00:36:21.000
"cannot open fname".

00:36:21.000 --> 00:36:26.000
And since this is a void function, I'm just going to return.

00:36:26.000 --> 00:36:29.000
Or, so I can do "return".

00:36:29.000 --> 00:36:31.000
Notice it's a void function.

00:36:31.000 --> 00:36:41.000
Or, I could skip this return.

00:36:41.000 --> 00:36:43.000
I could skip that return.

00:36:43.000 --> 00:36:47.000
And I could put the remaining part of the code in the "else" down here.

00:36:47.000 --> 00:36:49.000
So, I'll do that.

00:36:49.000 --> 00:36:54.000
I know specifically in 250 they don't like you putting this return inside there.

00:36:54.000 --> 00:36:57.000
So, I'll do that.

00:36:57.000 --> 00:36:59.000
I generally would do it.

00:36:59.000 --> 00:37:04.000
But, I'm trying to make it easier for you when you go on to the next class.

00:37:04.000 --> 00:37:07.000
So, we can't open the file name.

00:37:07.000 --> 00:37:10.000
If we didn't fail, what are we going to do?

00:37:10.000 --> 00:37:14.000
We're going to read the file and print it to output.

00:37:14.000 --> 00:37:16.000
So, I need two lines.

00:37:16.000 --> 00:37:18.000
I need to read two lines at a time.

00:37:18.000 --> 00:37:25.000
So, I'm going to have "string line1" and "line2".

00:37:25.000 --> 00:37:34.000
I'm going to say "while getline in line1".

00:37:34.000 --> 00:37:36.000
So, that's going to read one line.

00:37:36.000 --> 00:37:43.000
And now I'm going to say "if getline in line2".

00:37:43.000 --> 00:37:45.000
Now I've read two lines.

00:37:45.000 --> 00:37:49.000
If that fails, of course, I've only read one line.

00:37:49.000 --> 00:37:55.000
And then I'm going to do "cout".

00:37:55.000 --> 00:38:04.000
I'm going to print "line2", a new line, "line1", and a new line.

00:38:04.000 --> 00:38:22.000
If that failed, else, then of course I'm going to do "cout line1" and "line2" because we didn't read two lines.

00:38:22.000 --> 00:38:25.000
So, here's getting a file name in.

00:38:25.000 --> 00:38:27.000
Opening the file.

00:38:27.000 --> 00:38:34.000
If we can't open it, printing out an error message. Otherwise, reading and printing the output.

00:38:34.000 --> 00:38:38.000
So, let's try this. Let's open up a shell there.

00:38:38.000 --> 00:38:46.000
Let's do "make test".

00:38:46.000 --> 00:38:48.000
Oops.

00:38:48.000 --> 00:38:52.000
Sorry, I didn't want that. I guess because I had multiple ones there.

00:38:52.000 --> 00:39:02.000
I was trying to get rid of this extra one over here.

00:39:02.000 --> 00:39:04.000
Kind of too much work.

00:39:04.000 --> 00:39:09.000
"make test"

00:39:09.000 --> 00:39:15.000
Ok, so, here's an easy file that had a second line and a first line. It just replaced it.

00:39:15.000 --> 00:39:20.000
Here's trying to check the error message. Kind of an open, no loadout text.

00:39:20.000 --> 00:39:23.000
And here's the original test in here.

00:39:23.000 --> 00:39:27.000
Checking the file that was on the handout here.

00:39:27.000 --> 00:39:41.000
This file right here.

00:39:41.000 --> 00:39:47.000
Ok, so there's the whole function right there.

00:39:47.000 --> 00:39:53.000
Now, I, as I mentioned, I would probably do it like this.

00:39:53.000 --> 00:40:00.000
There's no reason to go on. I would remove that "else" part there.

00:40:00.000 --> 00:40:04.000
Because if I got here.

00:40:04.000 --> 00:40:13.000
I like that because it's a little bit shorter, personally.

00:40:13.000 --> 00:40:17.000
Alright, let's go on now.

00:40:17.000 --> 00:40:21.000
And look at token oriented dataloops.

00:40:21.000 --> 00:40:26.000
So this is what we started with today, while in VAR.

00:40:26.000 --> 00:40:29.000
We're reading one token at a time.

00:40:29.000 --> 00:40:36.000
Now this fails at end to file, like the other two loops do. The character oriented and the light oriented.

00:40:36.000 --> 00:40:40.000
And it fails when it can't convert the token.

00:40:40.000 --> 00:40:47.000
So if we failed because we couldn't convert a token, and we weren't at end to file,

00:40:47.000 --> 00:40:51.000
we'd need to clear the error flags with in.clear

00:40:51.000 --> 00:40:54.000
before we could read anything else.

00:40:54.000 --> 00:40:58.000
And then we'd still need to remove the offending input.

00:40:58.000 --> 00:41:04.000
So, here I've created a string just to hold the offending input.

00:41:04.000 --> 00:41:08.000
If in fail, in clear, in error data.

00:41:08.000 --> 00:41:17.000
So this clears the flags, this removes the token, and then we can keep going on

00:41:17.000 --> 00:41:21.000
to the remaining data.

00:41:21.000 --> 00:41:25.000
So we're going to look at a final exercise today.

00:41:25.000 --> 00:41:27.000
Expenses.

00:41:27.000 --> 00:41:32.000
We're going to process a file with characters and tokens.

00:41:32.000 --> 00:41:36.000
So we're going to learn a couple of tricks to doing that.

00:41:36.000 --> 00:41:40.000
So let's close flip lines.

00:41:40.000 --> 00:41:44.000
Let's open up d, expenses.cpp.

00:41:44.000 --> 00:41:49.000
Let's open expenses.txt too. So this is the file we're processing.

00:41:49.000 --> 00:41:53.000
What we want to do is we want to read each line.

00:41:53.000 --> 00:41:57.000
We want to sum up this person's expenses,

00:41:57.000 --> 00:42:02.000
print their name, and print their

00:42:02.000 --> 00:42:04.000
print their data out.

00:42:04.000 --> 00:42:10.000
Print the sum of their expenses.

00:42:10.000 --> 00:42:16.000
So let's add a comment on there. Notice we have an in file and an out file.

00:42:16.000 --> 00:42:19.000
We're going to open the input file.

00:42:19.000 --> 00:42:27.000
So if string in, in file.

00:42:27.000 --> 00:42:33.000
If we can't find it, if in fail.

00:42:33.000 --> 00:42:36.000
We're going to print an error message.

00:42:36.000 --> 00:42:47.000
Sierra cannot open in file.

00:42:47.000 --> 00:42:51.000
And I'm going to just return from that.

00:42:51.000 --> 00:42:54.000
Then we're going to create the output file.

00:42:54.000 --> 00:42:58.000
It says expenses summary, but we're going to use the name out file,

00:42:58.000 --> 00:43:00.000
which is created up here.

00:43:00.000 --> 00:43:08.000
So we're going to say OF string out,

00:43:08.000 --> 00:43:12.000
and I'm going to create it with out file.

00:43:12.000 --> 00:43:15.000
And we have to check to make sure that worked as well.

00:43:15.000 --> 00:43:20.000
So if out fail,

00:43:20.000 --> 00:43:29.000
Sierra cannot create out file,

00:43:29.000 --> 00:43:34.000
and I'll return there.

00:43:34.000 --> 00:43:38.000
Okay, so this is the setup before we do anything.

00:43:38.000 --> 00:43:42.000
Now we've opened both the input and output file,

00:43:42.000 --> 00:43:45.000
and we can loop through each character in the file.

00:43:45.000 --> 00:43:48.000
So let's write a loop that does that.

00:43:48.000 --> 00:43:51.000
I'm going to leave that up there

00:43:51.000 --> 00:43:56.000
and write it down here rather than writing inside it.

00:43:56.000 --> 00:44:06.000
So char ch while in get ch.

00:44:06.000 --> 00:44:09.000
Okay, so that's our main loop.

00:44:09.000 --> 00:44:12.000
Loop through each character in the file.

00:44:12.000 --> 00:44:18.000
Now if the character is a non-digit, then print it out.

00:44:18.000 --> 00:44:26.000
So if not is digit ch,

00:44:26.000 --> 00:44:35.000
out put ch.

00:44:35.000 --> 00:44:43.000
Otherwise, so else, we'll have some code inside here, the else.

00:44:43.000 --> 00:44:47.000
Okay, so we've read our first digit in the line.

00:44:47.000 --> 00:44:50.000
So again, let's look at expenses.txt.

00:44:50.000 --> 00:44:56.000
I read and printed that, that, that, that, that, that, that, that, that space,

00:44:56.000 --> 00:45:00.000
and now I've just read the two.

00:45:00.000 --> 00:45:07.000
So here I need to create and initialize a sum for the line.

00:45:07.000 --> 00:45:13.000
So double sum zero.

00:45:13.000 --> 00:45:20.000
I need to repeat until input fails or ch equals the null, right?

00:45:20.000 --> 00:45:30.000
So I need to say while in or while not in fail

00:45:30.000 --> 00:45:37.000
and ch is not equal to the null line.

00:45:37.000 --> 00:45:40.000
Now notice the instruction says until.

00:45:40.000 --> 00:45:46.000
We have to put it in the reverse sense and say keep going while this is true.

00:45:46.000 --> 00:45:50.000
Okay.

00:45:50.000 --> 00:46:00.000
So if ch is a digit,

00:46:00.000 --> 00:46:03.000
what we're going to do is put it back in the stream.

00:46:03.000 --> 00:46:12.000
So in put back ch

00:46:12.000 --> 00:46:18.000
or alternatively in unget would work as well.

00:46:18.000 --> 00:46:22.000
Now we need to read the entire number from the stream.

00:46:22.000 --> 00:46:24.000
So look at expenses.txt.

00:46:24.000 --> 00:46:28.000
We read the digit two, took it out of the stream,

00:46:28.000 --> 00:46:31.000
but we want to actually read this whole number.

00:46:31.000 --> 00:46:34.000
So we have to take the two and put it back in the stream

00:46:34.000 --> 00:46:37.000
so we're reading right from that point.

00:46:37.000 --> 00:46:40.000
Now to read that whole number and convert it, of course,

00:46:40.000 --> 00:46:44.000
what I need to use is formatted input.

00:46:44.000 --> 00:46:50.000
So I need to say double in, in, in.

00:46:50.000 --> 00:46:53.000
So we read the number from the stream.

00:46:53.000 --> 00:46:56.000
Of course we need to add the number to the sum.

00:46:56.000 --> 00:47:02.000
So sum plus equals in.

00:47:02.000 --> 00:47:06.000
Now if it's not a digit or even if it was a digit,

00:47:06.000 --> 00:47:10.000
after that loop we need to read the next digit.

00:47:10.000 --> 00:47:16.000
So in, get, ch.

00:47:16.000 --> 00:47:21.000
Now at the end of this while loop, after the loop is over,

00:47:21.000 --> 00:47:24.000
after we've done all of this stuff,

00:47:24.000 --> 00:47:28.000
we need to print the sum with two decimals and a new line.

00:47:28.000 --> 00:47:31.000
So that's right here.

00:47:31.000 --> 00:47:40.000
We need to say out, not cout, fixed, set precision,

00:47:40.000 --> 00:47:47.000
to, sum, end.

00:47:47.000 --> 00:47:51.000
Now we could actually put the out fixed precision up here

00:47:51.000 --> 00:47:54.000
even before the loop started, so we just have to do the sum.

00:47:54.000 --> 00:48:05.000
So this would be perfectly fine.

00:48:05.000 --> 00:48:11.000
And here we could just say out, sum, end out,

00:48:11.000 --> 00:48:23.000
and it kind of doesn't clutter up the flow of the control with the output.

00:48:23.000 --> 00:48:28.000
So here's our outer loop, well we can read a character.

00:48:28.000 --> 00:48:33.000
Here is our inner loop where we're summing up the numbers in one line

00:48:33.000 --> 00:48:43.000
and printing out the output.

00:48:43.000 --> 00:48:46.000
Okay, let's go ahead and try that and see how we did.

00:48:46.000 --> 00:48:56.000
Let's get a shell on that.

00:48:56.000 --> 00:49:04.000
So we're going to say make, and make test.

00:49:04.000 --> 00:49:11.000
Okay, so I tried to open a file that did not exist.

00:49:11.000 --> 00:49:16.000
I tried to open a file that you were not allowed to write to.

00:49:16.000 --> 00:49:21.000
And I tried to create a file with the correct input.

00:49:21.000 --> 00:49:22.000
That worked okay.

00:49:22.000 --> 00:49:28.000
Then I read the file, so that makes sure that I read the next correct number of lines.

00:49:28.000 --> 00:49:35.000
And then I correctly went through and read the, summed the data.

00:49:35.000 --> 00:49:45.000
Now you might wonder, you might wonder why I had to go to all this extra work inside here

00:49:45.000 --> 00:49:52.000
to read the, why I couldn't just do well in, arrow, arrow, end,

00:49:52.000 --> 00:49:54.000
and get it to work like that.

00:49:54.000 --> 00:50:01.000
Well notice, some of the people have put in notes inside here,

00:50:01.000 --> 00:50:04.000
and we have to make sure we skip over those.

00:50:04.000 --> 00:50:12.000
And so those would fail inside, inside that line.

00:50:12.000 --> 00:50:18.000
And so this last exercise we did, process a file with characters

00:50:18.000 --> 00:50:26.000
and with token oriented input, and opening files.

00:50:26.000 --> 00:50:29.000
Okay, that's it for today.

00:50:29.000 --> 00:50:34.000
And I will see you on the next lecture, on lecture 13.


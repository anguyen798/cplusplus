WEBVTT

00:00:00.000 --> 00:00:08.000
Hello everyone, this is Steve Gilbert. Welcome to lecture 10, where we're going to talk about recursion.

00:00:08.000 --> 00:00:17.000
Before we talk about recursion though, I want to look at the previous lecture, lecture 9, where we talked about writing functions.

00:00:17.000 --> 00:00:22.000
So programming exam 4, which you'll take next week, will ask you to write a function.

00:00:22.000 --> 00:00:30.000
And that function will have both input and output parameters, and so you need to be perfectly clear on that.

00:00:30.000 --> 00:00:36.000
Also, as a second problem, you'll be asked to write a group of prototypes.

00:00:36.000 --> 00:00:44.000
And you'll have to deduce the correct prototype based on the way that the function is called.

00:00:44.000 --> 00:00:49.000
And this will check your ability to apply the data flow checklists.

00:00:49.000 --> 00:00:56.000
Do you understand how data flows into a function, and how data flows out of a function?

00:00:56.000 --> 00:01:03.000
And if you understand that, do you understand how to write the prototypes so that they are correct?

00:01:03.000 --> 00:01:10.000
And so we're going to start with a review exercise before we get into recursion to test that.

00:01:10.000 --> 00:01:22.000
And so make sure that you have gone over to week 3, and on week 3 that you've gone to the recursion tab and clicked the lecture exercise tab.

00:01:22.000 --> 00:01:30.000
On the lecture exercise tab, make a copy of the starters, probably name it something rather than copy.

00:01:30.000 --> 00:01:36.000
And then we'll start by filling up this link.

00:01:36.000 --> 00:01:41.000
Ok, so I've been signed out, so it's going to ask me to sign in here for a second.

00:01:41.000 --> 00:01:45.000
And it signed me back in.

00:01:45.000 --> 00:01:51.000
Ok, so we're going to follow this link.

00:01:51.000 --> 00:01:54.000
Ok, I've made it a little larger.

00:01:54.000 --> 00:02:00.000
And so as you can see, we have a main function down here, the file called prototype_tester.cpp.

00:02:00.000 --> 00:02:04.000
And it calls five different functions.

00:02:04.000 --> 00:02:08.000
Your job is just to put the prototypes in the header file.

00:02:08.000 --> 00:02:11.000
So let's just look at the first one.

00:02:11.000 --> 00:02:15.000
Here on line 13, we're calling the function crypt.

00:02:15.000 --> 00:02:17.000
We're passing it false and a.

00:02:17.000 --> 00:02:21.000
As you can see on line 12, a is an int variable.

00:02:21.000 --> 00:02:25.000
Now my comment tells you what that's going to print. It's going to print 5.

00:02:25.000 --> 00:02:28.000
So that's going to tell us what's coming out of the function.

00:02:28.000 --> 00:02:33.000
And afterwards, it says that a, although it's an int, is going to be changed.

00:02:33.000 --> 00:02:38.000
It went in with the value 5 and it's coming out with the value 5.

00:02:38.000 --> 00:02:46.000
So let's prototype that, seeing that the first argument to crypt is an input parameter,

00:02:46.000 --> 00:02:50.000
because a literal must be an input parameter.

00:02:50.000 --> 00:02:55.000
The value false cannot be a reference or an output parameter.

00:02:55.000 --> 00:03:00.000
But a is an input. It goes in with 5 and it comes out with 10.

00:03:00.000 --> 00:03:04.000
And so this is an input/output parameter.

00:03:04.000 --> 00:03:10.000
And so the return type for this is crypt.

00:03:10.000 --> 00:03:13.000
The argument is bool.

00:03:13.000 --> 00:03:18.000
And the type of a is int.

00:03:18.000 --> 00:03:22.000
And since it's an input/output parameter, it's a primitive type.

00:03:22.000 --> 00:03:27.000
It's going to be changed in the function. It's passed by reference.

00:03:27.000 --> 00:03:35.000
Now you can give it name.

00:03:35.000 --> 00:03:40.000
Int reference t or something like that.

00:03:40.000 --> 00:03:45.000
But you don't have to give them names.

00:03:45.000 --> 00:03:51.000
Then each time you do each one, go ahead and check it.

00:03:51.000 --> 00:03:55.000
And so we're going to check that.

00:03:55.000 --> 00:03:59.000
And for each one, it will tell you whether it's syntactically correct.

00:03:59.000 --> 00:04:03.000
So we're checking the crypt prototype. We're checking the output.

00:04:03.000 --> 00:04:09.000
We're checking to see if it is syntactically correct and semantically correct.

00:04:09.000 --> 00:04:15.000
Now notice, you do not put on a body.

00:04:15.000 --> 00:04:20.000
We're not defining these. We're just implementing them.

00:04:20.000 --> 00:04:24.000
Now let's look at the second one. The second one is called ORD.

00:04:24.000 --> 00:04:28.000
It takes a string as its argument.

00:04:28.000 --> 00:04:32.000
It prints 3.0 so I can see the output is double.

00:04:32.000 --> 00:04:36.000
And notice the string went in with one value and out with another value.

00:04:36.000 --> 00:04:45.000
So ORD. It's going to return a double.

00:04:45.000 --> 00:04:49.000
The function is named ORD.

00:04:49.000 --> 00:04:53.000
And it takes a string as its parameter.

00:04:53.000 --> 00:04:56.000
Now let's try this.

00:04:56.000 --> 00:05:03.000
I'm doing things wrong to show you a couple of errors.

00:05:03.000 --> 00:05:06.000
And you will see that that doesn't even compile.

00:05:06.000 --> 00:05:11.000
It doesn't even compile. String was not declared in this scope.

00:05:11.000 --> 00:05:14.000
So I don't know why we're getting the error on line 32.

00:05:14.000 --> 00:05:20.000
But on line 7, we're getting an error. String was not declared.

00:05:20.000 --> 00:05:32.000
So because it's in the header file, all regular types, all library types, must be fully qualified.

00:05:32.000 --> 00:05:39.000
So we cannot use using namespace standard there. We have to put in the fully qualified name.

00:05:39.000 --> 00:05:42.000
So let's try it now.

00:05:42.000 --> 00:05:45.000
Okay, so now it compiled.

00:05:45.000 --> 00:05:53.000
Notice that it is syntactically correct, that type string was correct, but we didn't get the semantic part about it.

00:05:53.000 --> 00:05:57.000
Whether it's an input or output parameter.

00:05:57.000 --> 00:06:06.000
So we are passing our string here by value, when in fact we need to pass it by reference.

00:06:06.000 --> 00:06:11.000
So for all string types, we'll always pass them by reference.

00:06:11.000 --> 00:06:18.000
And when we just make that change and we test it again, you can see that it now is not only syntactically correct,

00:06:18.000 --> 00:06:23.000
but it is now semantically correct as well.

00:06:23.000 --> 00:06:28.000
So let's do the other ones real quick. ReadLink has no return value.

00:06:28.000 --> 00:06:33.000
It takes a literal for the first argument, so that's double.

00:06:33.000 --> 00:06:37.000
This literal again, that is bool.

00:06:37.000 --> 00:06:42.000
And this is a literal, so that is a const string reference.

00:06:42.000 --> 00:06:47.000
So it doesn't return anything, so it's void.

00:06:47.000 --> 00:06:50.000
This function is named ReadLink.

00:06:50.000 --> 00:06:59.000
It's a double const standard string reference and bool.

00:06:59.000 --> 00:07:12.000
The fourth one, dbclose, prints okay, so it's going to return a standard string.

00:07:12.000 --> 00:07:21.000
It takes a string literal, so that's a constant string ref.

00:07:21.000 --> 00:07:27.000
So const standard string reference.

00:07:27.000 --> 00:07:33.000
And it takes 42, again another literal, and its type is int.

00:07:33.000 --> 00:07:37.000
And finally require takes two arguments.

00:07:37.000 --> 00:07:41.000
S is a string down here, and okay is a bool.

00:07:41.000 --> 00:07:49.000
But notice that okay is not initialized, and so this must be an output parameter.

00:07:49.000 --> 00:07:52.000
So that must be a bool ref.

00:07:52.000 --> 00:07:58.000
This string sam goes in. Is it going to be an input parameter?

00:07:58.000 --> 00:08:04.000
No, afterwards S has sam, sam, sam, all proper case.

00:08:04.000 --> 00:08:10.000
And so it's an input/output parameter, and so that is a reference.

00:08:10.000 --> 00:08:16.000
So this returns a standard string.

00:08:16.000 --> 00:08:20.000
The function is named require.

00:08:20.000 --> 00:08:30.000
It takes a standard string by reference, and it takes a bool by reference.

00:08:30.000 --> 00:08:36.000
Okay, now I've done all three of them, just so that we don't spend a lot of time in the video here.

00:08:36.000 --> 00:08:40.000
But you should do them one at a time and make sure you get them correct.

00:08:40.000 --> 00:08:43.000
If one of them doesn't work, just skip that one.

00:08:43.000 --> 00:08:48.000
Comment it out, especially if you get syntax errors on this.

00:08:48.000 --> 00:08:51.000
Especially if you get syntax errors.

00:08:51.000 --> 00:08:55.000
Okay, so here is all of our tests working correctly.

00:08:55.000 --> 00:08:59.000
And you can shoot your screenshot for that.

00:08:59.000 --> 00:09:06.000
Okay, so let's go now and talk about recursion.

00:09:06.000 --> 00:09:08.000
What's recursion?

00:09:08.000 --> 00:09:11.000
So recursion is a mathematical concept.

00:09:11.000 --> 00:09:16.000
In math, a recursive function is one that's defined in terms of itself.

00:09:16.000 --> 00:09:19.000
Like the factorial function.

00:09:19.000 --> 00:09:28.000
The factorial function, f factorial, the definition for it is 3 factorial is 3 times 2 times 1 factorial.

00:09:28.000 --> 00:09:33.000
And 4 factorial is 4 times 3 times 2 times 1.

00:09:33.000 --> 00:09:41.000
And since we can see that 4 factorial is just 4 times what 3 factorial is, we can generalize that.

00:09:41.000 --> 00:09:52.000
So that for any n, like 3 or 4 or 12 or whatever, n factorial is n times n minus 1 factorial.

00:09:52.000 --> 00:09:55.000
So let's try that with n equals 2.

00:09:55.000 --> 00:10:01.000
So 2 factorial is 2 times 2 minus 1 factorial.

00:10:01.000 --> 00:10:10.000
And 2 minus 1 factorial is 1 times 1 minus 1 factorial or 0 factorial.

00:10:10.000 --> 00:10:17.000
And 0 factorial is and so forth and so on.

00:10:17.000 --> 00:10:24.000
You can see that if we just use this definition, n equals n times n minus 1 factorial, we have a problem.

00:10:24.000 --> 00:10:26.000
We have a circular definition.

00:10:26.000 --> 00:10:34.000
And so what we always have to do with a recursive mathematical function is we have to find the qualification.

00:10:34.000 --> 00:10:40.000
The qualification for this is that 0 factorial is 1.

00:10:40.000 --> 00:10:41.000
0 factorial is 1.

00:10:41.000 --> 00:10:52.000
Because otherwise when we got this 1 times 1 factorial, 1 times 1 times 1 factorial, and that would be 0 factorial.

00:10:52.000 --> 00:10:57.000
Now if we didn't know what 0 factorial is, we would have to put it through this formula again.

00:10:57.000 --> 00:11:04.000
And we would get minus 1, minus 2, minus 3, which just wouldn't work.

00:11:04.000 --> 00:11:11.000
So in programming, however, a recursive function is a function that calls itself.

00:11:11.000 --> 00:11:16.000
So when a function calls itself, it's a recursive function.

00:11:16.000 --> 00:11:22.000
So let's look at a recursive function, elevator.cpp, and examine it.

00:11:22.000 --> 00:11:27.000
So again, make sure that you have stopped my code space.

00:11:27.000 --> 00:11:31.000
I'm going to start my code space again.

00:11:31.000 --> 00:11:33.000
Restart my code space.

00:11:33.000 --> 00:11:56.000
And so again, make sure that you have opened up the Week 10 in your IDE.

00:11:56.000 --> 00:12:06.000
So that is in IC, IC10, a elevator.

00:12:06.000 --> 00:12:20.000
So here's our elevator problem right here.

00:12:20.000 --> 00:12:26.000
Let me pause that while I clear this up.

00:12:26.000 --> 00:12:29.000
Okay, I'm back, and I'm probably not going to edit that out.

00:12:29.000 --> 00:12:31.000
So here's the elevator.cpp.

00:12:31.000 --> 00:12:36.000
And so notice we've prototyped the function called elevator that takes a floor.

00:12:36.000 --> 00:12:41.000
In the main function, we're calling elevator sub 0.

00:12:41.000 --> 00:12:49.000
Now the elevator function gets one argument, its floor, and then it prints out the floor that you're on.

00:12:49.000 --> 00:12:51.000
And it says going up.

00:12:51.000 --> 00:12:54.000
So going up, floor, and it prints out floor 0.

00:12:54.000 --> 00:13:00.000
Then it calls itself again, elevator floor plus 1.

00:13:00.000 --> 00:13:04.000
And so now it's going to say going up floor 1.

00:13:04.000 --> 00:13:09.000
And then of course it's going to call itself again, and it's going to say going up floor 2.

00:13:09.000 --> 00:13:11.000
So let's go ahead and run that.

00:13:11.000 --> 00:13:15.000
Right click and open a terminal there.

00:13:15.000 --> 00:13:20.000
And then let's do make run.

00:13:20.000 --> 00:13:26.000
And you can see it does in fact look like an endless loop.

00:13:26.000 --> 00:13:32.000
An endless loop effect, except something is different here.

00:13:32.000 --> 00:13:44.000
And so what happens is that we get an endless loop effect, but unlike an endless loop effect, the program eventually crashes.

00:13:44.000 --> 00:13:55.000
That's because each time elevator is called, a new variable is created, a new copy of the floor variable with a new value.

00:13:55.000 --> 00:14:00.000
And it's placed in an area of memory here called the stack.

00:14:00.000 --> 00:14:12.000
Now as more and more floor variables are created, eventually that fills up and we run out of memory and the stack collides with the heap.

00:14:12.000 --> 00:14:17.000
And this specific kind of error is called a stack overflow.

00:14:17.000 --> 00:14:21.000
And that's very, very frequent in recursive programs actually.

00:14:21.000 --> 00:14:25.000
It's probably the only way you can create a stack overflow.

00:14:25.000 --> 00:14:30.000
You notice unlike Java, we didn't get a nice error message, stack overflow.

00:14:30.000 --> 00:14:35.000
Java inspects this with its Java virtual machine.

00:14:35.000 --> 00:14:48.000
C++ does not. It relies on the operating system to notice when your program has started overflowing the memory that was allocated for it and starts using the memory that it's not supposed to use.

00:14:48.000 --> 00:14:58.000
And so a segmentation fault is simply an error message from the operating system, not from C++ itself.

00:14:58.000 --> 00:15:09.000
So basically that says your program crashed because you did something the operating system wouldn't let you do.

00:15:09.000 --> 00:15:12.000
So how do we fix that?

00:15:12.000 --> 00:15:15.000
Well how do we fix an endless loop?

00:15:15.000 --> 00:15:20.000
We fix an endless loop by providing a loop bounds.

00:15:20.000 --> 00:15:23.000
Recursive functions need the same thing. They need a way to stop.

00:15:23.000 --> 00:15:27.000
In a recursive function this is called the base case.

00:15:27.000 --> 00:15:30.000
Now it's very similar to a loop bounds.

00:15:30.000 --> 00:15:33.000
What you do is you add an if statement.

00:15:33.000 --> 00:15:38.000
Every recursive function will have an if statement.

00:15:38.000 --> 00:15:42.000
And the if statement determines when a function is called again.

00:15:42.000 --> 00:15:46.000
If the if statement is false, we don't call it again.

00:15:46.000 --> 00:15:52.000
So this creates the loop-like effect that you saw, but remember it is not a loop.

00:15:52.000 --> 00:15:57.000
You're not inside the same function. You're in a copy of the function.

00:15:57.000 --> 00:16:00.000
And we'll see how that works shortly.

00:16:00.000 --> 00:16:10.000
So let's do that. Let's put in a base case to stop at the penthouse floor 25.

00:16:10.000 --> 00:16:14.000
So here's our code.

00:16:14.000 --> 00:16:18.000
Let me just minimize that here. Here's our code.

00:16:18.000 --> 00:16:29.000
We'll create a constant here. So constant penthouse k penthouse equals 25.

00:16:29.000 --> 00:16:34.000
And so before we call the function, we're going to check to see if it's okay.

00:16:34.000 --> 00:16:44.000
And so we're going to say if floor is less than the penthouse,

00:16:44.000 --> 00:16:53.000
then we're going to go ahead and go up to the next floor.

00:16:53.000 --> 00:16:58.000
If it's not, we're not. If it's not, we're not.

00:16:58.000 --> 00:17:08.000
So this is the idea of the base case, the terminator for a recursive function.

00:17:08.000 --> 00:17:14.000
So let's try it again.

00:17:14.000 --> 00:17:18.000
And let's do make run again.

00:17:18.000 --> 00:17:22.000
And notice we go up floor 1, 2, 3, 4, just like we had a loop.

00:17:22.000 --> 00:17:26.000
When we get to floor 25, though, we end.

00:17:26.000 --> 00:17:30.000
Now look at the format of the code.

00:17:30.000 --> 00:17:43.000
Look at that our call to the function is inside this guarded if statement.

00:17:43.000 --> 00:17:47.000
So this is a guarded action.

00:17:47.000 --> 00:17:52.000
What happens if we put code that's outside of that if statement?

00:17:52.000 --> 00:18:02.000
Well, if it appears after the guarded action, for instance, if we take this statement

00:18:02.000 --> 00:18:14.000
and we print it again, change it to going down,

00:18:14.000 --> 00:18:22.000
this code will execute after we have executed all of the copies of going up.

00:18:22.000 --> 00:18:28.000
Only when we're going up, when we're at floor 25, will we start going down.

00:18:28.000 --> 00:18:36.000
And even though it looks like we would only have going down floor 25 and then the function would end,

00:18:36.000 --> 00:18:40.000
only one copy of the function ends.

00:18:40.000 --> 00:18:46.000
And so when we do this and we run it again, notice we go up to floor 25

00:18:46.000 --> 00:18:54.000
and then we go down to floor 24, floor 23, floor 22, floor 21, and so forth.

00:18:54.000 --> 00:19:03.000
And so this is called unwinding the stack.

00:19:03.000 --> 00:19:08.000
So as we go up, we put the variables on the stack.

00:19:08.000 --> 00:19:14.000
When we leave, we remove them off the stack and we can use those variables again.

00:19:14.000 --> 00:19:18.000
So that's kind of confusing the first time you see it.

00:19:18.000 --> 00:19:25.000
So let me show you an example so you'll see exactly what happens.

00:19:25.000 --> 00:19:30.000
So in this case, here's the factorial function we're going to look at.

00:19:30.000 --> 00:19:35.000
So remember the n factorial is n times n minus 1 factorial with the convention.

00:19:35.000 --> 00:19:44.000
That's the recursive case. With the base case, the 0 factorial or 1 factorial is 1.

00:19:44.000 --> 00:19:46.000
So let's do a simulation of that.

00:19:46.000 --> 00:19:54.000
Here's a little animation with a little terminal like a Macintosh terminal.

00:19:54.000 --> 00:19:56.000
We're going to print out enter n.

00:19:56.000 --> 00:20:01.000
The user is going to type in a value like 5.

00:20:01.000 --> 00:20:06.000
We're going to save that in a local variable n inside the main function.

00:20:06.000 --> 00:20:11.000
And then we're going to print out n factorial equals the factorial of n.

00:20:11.000 --> 00:20:14.000
In this case, the factorial of 5.

00:20:14.000 --> 00:20:18.000
Well, to do that, we first have to figure out what the factorial of 5 is.

00:20:18.000 --> 00:20:21.000
And to do that, we call the function.

00:20:21.000 --> 00:20:25.000
And when we call the function, it creates what's called a stack frame.

00:20:25.000 --> 00:20:29.000
And this stack frame will have its own variables.

00:20:29.000 --> 00:20:37.000
So when we called the factorial of 5, we passed 5 to this local variable, a copy of the n here.

00:20:37.000 --> 00:20:43.000
And we put it in a local variable inside the function, specifically the parameter variable.

00:20:43.000 --> 00:20:46.000
And now we start running this function.

00:20:46.000 --> 00:20:49.000
If n equals 0, we're going to return 1.

00:20:49.000 --> 00:20:56.000
It's not 0, so we're going to return n or 5 times the factorial of n minus 1.

00:20:56.000 --> 00:20:58.000
What's the problem?

00:20:58.000 --> 00:21:01.000
We don't know what the factorial of n minus 1 is.

00:21:01.000 --> 00:21:03.000
How do we solve that problem?

00:21:03.000 --> 00:21:06.000
We call the factorial function again.

00:21:06.000 --> 00:21:08.000
We create another stack frame.

00:21:08.000 --> 00:21:12.000
This time, the local variable is 4, because that's what we passed to it.

00:21:12.000 --> 00:21:15.000
Notice we passed factorial of n minus 1.

00:21:15.000 --> 00:21:19.000
So the local variable in this frame is 4.

00:21:19.000 --> 00:21:32.000
And we just keep doing that until we hit the base case.

00:21:32.000 --> 00:21:37.000
So in this case, n is 0, and so we're going to return 1.

00:21:37.000 --> 00:21:39.000
Where do we turn the 1 to?

00:21:39.000 --> 00:21:43.000
We return the 1 to the function that called it.

00:21:43.000 --> 00:21:47.000
And so now we know what the expression, the compiler, can calculate.

00:21:47.000 --> 00:21:52.000
1 times 1, and it can return that to the previous stack frame.

00:21:52.000 --> 00:21:56.000
And now it can calculate 1 times 2, return that to the previous stack frame.

00:21:56.000 --> 00:21:59.000
2 times 3, return that.

00:21:59.000 --> 00:22:02.000
6 times 4, return that.

00:22:02.000 --> 00:22:07.000
And finally, we've got rid of all the calls to factorial n,

00:22:07.000 --> 00:22:10.000
and we're returning 5 times 24.

00:22:10.000 --> 00:22:14.000
And we can complete or execute that statement.

00:22:14.000 --> 00:22:19.000
So 5 factorial is 120.

00:22:19.000 --> 00:22:25.000
So it helps to keep this in mind, keep this little animation in mind,

00:22:25.000 --> 00:22:32.000
when you're thinking about how recursive functions work.

00:22:32.000 --> 00:22:39.000
So we can write problems, we can write functions, that solve recursive problems

00:22:39.000 --> 00:22:42.000
by following this simple pattern.

00:22:42.000 --> 00:22:47.000
If we know what the answer is, if n equals 0,

00:22:47.000 --> 00:22:50.000
we simply directly return the solution.

00:22:50.000 --> 00:22:55.000
So every recursive function will have this if else inside there.

00:22:55.000 --> 00:22:59.000
Now it's very common in recursive functions just to skip the else,

00:22:59.000 --> 00:23:04.000
because we'll just return the answer, and that way anything after the if

00:23:04.000 --> 00:23:07.000
basically is the else part.

00:23:07.000 --> 00:23:09.000
Then we'll call the function again.

00:23:09.000 --> 00:23:15.000
We'll split it up into simpler, smaller problems of the same structure.

00:23:15.000 --> 00:23:20.000
So we'll call it with a simpler value and get that out.

00:23:20.000 --> 00:23:23.000
We'll keep doing that until we get to the base case.

00:23:23.000 --> 00:23:28.000
Then we'll combine all those results by walking back up the stack,

00:23:28.000 --> 00:23:34.000
unwinding the stack, and combine the results to get the overall solution.

00:23:34.000 --> 00:23:36.000
Now that sounds much more complex than it is,

00:23:36.000 --> 00:23:39.000
so let me give you an example.

00:23:39.000 --> 00:23:43.000
You'll see that it is relatively simple.

00:23:43.000 --> 00:23:49.000
So we're going to look at this situation where you have children's blocks,

00:23:49.000 --> 00:23:52.000
and you want to build pyramids with those blocks.

00:23:52.000 --> 00:23:58.000
I want to know how many blocks do I need to build a pyramid of height or base,

00:23:58.000 --> 00:24:01.000
height and base are the same in all these things,

00:24:01.000 --> 00:24:05.000
height or base of 10.

00:24:05.000 --> 00:24:09.000
So a height or base of 1 obviously needs 1 block.

00:24:09.000 --> 00:24:14.000
A height or base of 2 needs 3 blocks.

00:24:14.000 --> 00:24:18.000
A height or base of 3 needs 6 blocks.

00:24:18.000 --> 00:24:22.000
And a height or base of 4 needs 10 blocks.

00:24:22.000 --> 00:24:24.000
So these are called triangle numbers.

00:24:24.000 --> 00:24:31.000
How do we write a function that figures out how many I need for a height of 10?

00:24:31.000 --> 00:24:33.000
Do I need 20? Do I need 50?

00:24:33.000 --> 00:24:35.000
How many do I need?

00:24:35.000 --> 00:24:40.000
And so to solve this, we'll figure out what the recursive definition is.

00:24:40.000 --> 00:24:43.000
Now the total blocks in the base, or the height,

00:24:43.000 --> 00:24:49.000
is the base plus the blocks in the next smaller triangle.

00:24:49.000 --> 00:24:57.000
So here's a base 4, and that's equal to 4 plus all the blocks in triangle 3.

00:24:57.000 --> 00:25:02.000
So that intrinsically gives me a recursive definition.

00:25:02.000 --> 00:25:09.000
A triangle of n is n plus the triangle of n minus 1.

00:25:09.000 --> 00:25:12.000
And the first triangle, base 1, we solve as 1.

00:25:12.000 --> 00:25:14.000
What if there are no blocks?

00:25:14.000 --> 00:25:18.000
Well, that's an area of 0. No blocks.

00:25:18.000 --> 00:25:22.000
So width of 0 has an area of 0.

00:25:22.000 --> 00:25:26.000
So this is our base case, or terminator.

00:25:26.000 --> 00:25:30.000
So let's go ahead and try that in our IDE now.

00:25:30.000 --> 00:25:33.000
We're going to complete the triangle function.

00:25:33.000 --> 00:25:35.000
It is B, I believe.

00:25:35.000 --> 00:25:44.000
So let's go ahead and close that one down, open up the thing over here.

00:25:44.000 --> 00:25:48.000
Close A, open B, and open up triangle.cpp.

00:25:48.000 --> 00:25:50.000
Let me close the elevator.

00:25:50.000 --> 00:25:53.000
Let me also open a terminal on it.

00:25:53.000 --> 00:25:56.000
Let's open an integrated terminal.

00:25:56.000 --> 00:25:58.000
So we're writing the recursive function triangle.

00:25:58.000 --> 00:26:00.000
You have a pair of no blocks.

00:26:00.000 --> 00:26:02.000
The topmost row has one block.

00:26:02.000 --> 00:26:03.000
Row belief has two.

00:26:03.000 --> 00:26:05.000
The next has three, and so forth.

00:26:05.000 --> 00:26:08.000
We're going to compute recursively, no loops or multiplication,

00:26:08.000 --> 00:26:12.000
the total number of blocks in such a triangle with the number of rows.

00:26:12.000 --> 00:26:14.000
Notice there are no blocks.

00:26:14.000 --> 00:26:16.000
Your function should return 0.

00:26:16.000 --> 00:26:22.000
So let's put our name on this.

00:26:22.000 --> 00:26:30.000
So the function is going to return an int.

00:26:30.000 --> 00:26:32.000
It's going to take an int.

00:26:32.000 --> 00:26:37.000
I'm going to call it base, or height would be fine there.

00:26:37.000 --> 00:26:39.000
So what's the one I know?

00:26:39.000 --> 00:26:40.000
No blocks.

00:26:40.000 --> 00:26:42.000
The simplest one.

00:26:42.000 --> 00:26:54.000
If base is 0, then return 0.

00:26:54.000 --> 00:27:02.000
Now, if base is not 0, I need to figure out n base.

00:27:02.000 --> 00:27:14.000
So I'm going to return base times triangle base minus 1,

00:27:14.000 --> 00:27:16.000
the next smallest one.

00:27:16.000 --> 00:27:20.000
And it's actually not times, it's plus.

00:27:20.000 --> 00:27:22.000
Base plus.

00:27:22.000 --> 00:27:28.000
Let's go back and look at our definition.

00:27:28.000 --> 00:27:35.000
So base plus triangle base minus 1.

00:27:35.000 --> 00:27:38.000
So we started with the base case.

00:27:38.000 --> 00:27:41.000
We wrote an if statement that returned that.

00:27:41.000 --> 00:27:44.000
Now we're going to figure out what the recursive case is.

00:27:44.000 --> 00:27:49.000
It's base plus the base of the next case.

00:27:49.000 --> 00:27:52.000
And then you call the triangle function with an argument

00:27:52.000 --> 00:27:56.000
that moves you closer to the base case.

00:27:56.000 --> 00:27:58.000
So let's try it.

00:27:58.000 --> 00:28:02.000
Let's go ahead and do that.

00:28:02.000 --> 00:28:05.000
Let's do make test.

00:28:05.000 --> 00:28:09.000
And you can see that it first makes sure that you're running

00:28:09.000 --> 00:28:10.000
this recursively.

00:28:10.000 --> 00:28:13.000
That's what this find the base case is.

00:28:13.000 --> 00:28:16.000
If you tried to do this with loops,

00:28:16.000 --> 00:28:20.000
it would say it doesn't appear to be recursive,

00:28:20.000 --> 00:28:22.000
if you didn't do it recursively.

00:28:22.000 --> 00:28:25.000
So you have to think about that paradigm.

00:28:25.000 --> 00:28:28.000
You have to think, solve the smallest thing,

00:28:28.000 --> 00:28:35.000
then call the function again to solve the remainder portion of it.

00:28:35.000 --> 00:28:39.000
OK, so that looks pretty good for triangles.

00:28:39.000 --> 00:28:42.000
Let's try another one.

00:28:42.000 --> 00:28:47.000
How about raising a number by the power?

00:28:47.000 --> 00:28:52.000
So 2 to the second power is 2 times 2.

00:28:52.000 --> 00:28:56.000
2 to the third power is 2 times 2 times 2.

00:28:56.000 --> 00:29:00.000
2 to the fourth power is 2 times 2 times 2 times 2.

00:29:00.000 --> 00:29:08.000
But we can recursively define that as any number to any exponent

00:29:08.000 --> 00:29:13.000
is the number times the number raised to the power

00:29:13.000 --> 00:29:16.000
of the smaller exponent.

00:29:16.000 --> 00:29:22.000
So 2 times 4 is 2 times 2 to the third.

00:29:22.000 --> 00:29:30.000
2 to the fourth is 2 times 2 to the third.

00:29:30.000 --> 00:29:36.000
And 2 to the 100th is 2 times 2 to the 99th power.

00:29:36.000 --> 00:29:41.000
So that's the recursive idea with the power function.

00:29:41.000 --> 00:29:45.000
So let's open up that one.

00:29:45.000 --> 00:29:47.000
Let me close the triangle.

00:29:47.000 --> 00:29:52.000
Let me close these different BASH shells I have here.

00:29:52.000 --> 00:29:57.000
Let's go down to C.

00:29:57.000 --> 00:30:05.000
Let's put our name on it.

00:30:05.000 --> 00:30:10.000
And so again, we want the power of a function

00:30:10.000 --> 00:30:19.000
that takes a number and an exponent.

00:30:19.000 --> 00:30:25.000
We know that the power of anything to the first power is that number.

00:30:25.000 --> 00:30:30.000
We also know that any number to the zeroth power is 1.

00:30:30.000 --> 00:30:32.000
So that's a simpler one.

00:30:32.000 --> 00:30:36.000
So we're going to use that for our base case.

00:30:36.000 --> 00:30:48.000
So if exponent is 0, we're going to return 1.

00:30:48.000 --> 00:30:55.000
If the exponent is not 0, we're going to return the number

00:30:55.000 --> 00:31:08.000
times the power of that number to the less smaller exponent.

00:31:08.000 --> 00:31:16.000
So this is 2 times the power of 2 to...

00:31:16.000 --> 00:31:22.000
So if I want 2 to the fourth, it would be 2 times the power of 2 to the third.

00:31:22.000 --> 00:31:26.000
And this just calls itself over and over again.

00:31:26.000 --> 00:31:30.000
So let's open a shell on that. Right click.

00:31:30.000 --> 00:31:33.000
Open an integrated terminal.

00:31:33.000 --> 00:31:38.000
Let's do make test.

00:31:38.000 --> 00:31:41.000
And again, I'm checking to make sure this is recursive.

00:31:41.000 --> 00:31:45.000
If you write this without recursion, by writing a loop,

00:31:45.000 --> 00:31:50.000
or simply writing a whole bunch of if statements, it won't give you the correct answer.

00:31:50.000 --> 00:31:54.000
It will tell you that it's not recursive.

00:31:54.000 --> 00:31:57.000
Let's do one fourth one here, or one third one here,

00:31:57.000 --> 00:32:02.000
just to get an idea of how you write these simple recursive functions.

00:32:02.000 --> 00:32:05.000
We're going to write a function changeX to Y

00:32:05.000 --> 00:32:09.000
that will take in a string and produce a new string.

00:32:09.000 --> 00:32:13.000
But for every lowercase x in the first string,

00:32:13.000 --> 00:32:17.000
we're going to replace it with a lowercase y.

00:32:17.000 --> 00:32:23.000
So let's close the power.

00:32:23.000 --> 00:32:26.000
Let's go down here to D.

00:32:26.000 --> 00:32:29.000
ChangeX to Y.

00:32:29.000 --> 00:32:35.000
Put our name on it.

00:32:35.000 --> 00:32:39.000
OK, so this is going to return a new string.

00:32:39.000 --> 00:32:43.000
The function is named changeX to Y.

00:32:43.000 --> 00:32:48.000
It's going to take a string that is not modified,

00:32:48.000 --> 00:32:55.000
so const string reference str.

00:32:55.000 --> 00:33:02.000
Now, if the string has one character, do we need to change it?

00:33:02.000 --> 00:33:06.000
Only if it's x, right?

00:33:06.000 --> 00:33:09.000
Then we need to change it to y.

00:33:09.000 --> 00:33:13.000
If it has no characters, do we need to change it?

00:33:13.000 --> 00:33:16.000
No, if it has no characters, we don't have to do any other thinking about it.

00:33:16.000 --> 00:33:19.000
We know that that's the answer.

00:33:19.000 --> 00:33:29.000
So if string size is less than one,

00:33:29.000 --> 00:33:33.000
then return the empty string.

00:33:33.000 --> 00:33:37.000
Or return quote, quote would be fine.

00:33:37.000 --> 00:33:40.000
Now we know I have at least one character.

00:33:40.000 --> 00:33:46.000
So if that one character is an x, I need to change it to a y.

00:33:46.000 --> 00:33:54.000
So let's save that in a variable.

00:33:54.000 --> 00:33:59.000
I'll use string here.

00:33:59.000 --> 00:34:05.000
Equals str. substring 0 and 1.

00:34:05.000 --> 00:34:20.000
So if front, I want to change it to y.

00:34:20.000 --> 00:34:24.000
And then I want to recursively call it, so I've handled one character.

00:34:24.000 --> 00:34:26.000
But I haven't handled the rest of the characters.

00:34:26.000 --> 00:34:29.000
How am I going to handle the rest of the characters?

00:34:29.000 --> 00:34:31.000
I'm going to call changeX to y.

00:34:31.000 --> 00:34:36.000
So this is going to return front, which has now been changed.

00:34:36.000 --> 00:34:45.000
Plus changeX to y.

00:34:45.000 --> 00:34:49.000
And I'm going to call it with the string.

00:34:49.000 --> 00:34:53.000
substring 1.

00:34:53.000 --> 00:34:57.000
I've already handled the first characters,

00:34:57.000 --> 00:35:01.000
and now I'm passing the second character, the third character, the fourth character,

00:35:01.000 --> 00:35:05.000
and so forth.

00:35:05.000 --> 00:35:08.000
So let's get one more terminal here.

00:35:08.000 --> 00:35:13.000
Right click, open an integrated terminal.

00:35:13.000 --> 00:35:18.000
And then let's do make test.

00:35:18.000 --> 00:35:34.000
And there that changes X to Y with those four lines of code.

00:35:34.000 --> 00:35:44.000
All right. Now let's talk a little bit about efficiency.

00:35:44.000 --> 00:35:52.000
So here is a function from your textbook to check to see if a string is a palindrome.

00:35:52.000 --> 00:35:57.000
So if a string has one character, it is a palindrome.

00:35:57.000 --> 00:36:05.000
So we don't need to check it at all if it is one character or less.

00:36:05.000 --> 00:36:09.000
However, if it is two characters or less,

00:36:09.000 --> 00:36:11.000
we have to make sure both the characters are the same,

00:36:11.000 --> 00:36:14.000
the one at the beginning and the one at the end.

00:36:14.000 --> 00:36:17.000
And so if the length is greater than one,

00:36:17.000 --> 00:36:22.000
we check to see if string 0 equals string length 1,

00:36:22.000 --> 00:36:24.000
in other words, the first and the last,

00:36:24.000 --> 00:36:29.000
we could have said str.front, called the front function, and str.back.

00:36:29.000 --> 00:36:33.000
That would have worked fine as well.

00:36:33.000 --> 00:36:39.000
And if the string is only two characters long, it's a palindrome.

00:36:39.000 --> 00:36:42.000
Then we check if it's not.

00:36:42.000 --> 00:36:45.000
If it's larger, we have to check if the rest of it,

00:36:45.000 --> 00:36:48.000
the part inside the first and last characters,

00:36:48.000 --> 00:36:52.000
if it's larger than two characters, is a palindrome.

00:36:52.000 --> 00:36:56.000
And so we do that by calling isPalindrome again

00:36:56.000 --> 00:37:00.000
with the string with the first character removed

00:37:00.000 --> 00:37:04.000
and the last character removed right here.

00:37:04.000 --> 00:37:07.000
Now this function is correct, but it's inefficient.

00:37:07.000 --> 00:37:12.000
It's inefficient because when I call this substring function,

00:37:12.000 --> 00:37:18.000
I have to create a new string object and put it on the stack.

00:37:18.000 --> 00:37:24.000
And so each time I call, each time I recursively call the function,

00:37:24.000 --> 00:37:27.000
I put a new string on the stack, which is expensive.

00:37:27.000 --> 00:37:31.000
It would be nicer if I could skip that.

00:37:31.000 --> 00:37:37.000
And so what I can do is instead of calling,

00:37:37.000 --> 00:37:41.000
instead of recursively going through the string with isPalindrome,

00:37:41.000 --> 00:37:46.000
I can call another function that is itself recursive.

00:37:46.000 --> 00:37:50.000
We call that other function that is self-recursive a helper,

00:37:50.000 --> 00:37:55.000
and then palindrome is not recursive, but it calls a recursive function,

00:37:55.000 --> 00:37:58.000
so we say it's a recursive wrapper.

00:37:58.000 --> 00:38:04.000
And what we would do in isPalindrome is we'd call helper

00:38:04.000 --> 00:38:10.000
with the original string, and then we would pass two additional arguments,

00:38:10.000 --> 00:38:14.000
the index to the beginning and the index to the end.

00:38:14.000 --> 00:38:18.000
If you want to see how this is implemented, you can look at

00:38:18.000 --> 00:38:24.000
the function on page 7 of your reading in this chapter.

00:38:24.000 --> 00:38:30.000
So that's one reason a function might be inefficient if it is recursive,

00:38:30.000 --> 00:38:38.000
if it creates using substring, like our last example did, additional copies.

00:38:38.000 --> 00:38:45.000
A function can also be inefficient because it calls itself too many times.

00:38:45.000 --> 00:38:51.000
So most of you are familiar with the Fibonacci sequence 0, 1, 1, 2, 3, 5, 8,

00:38:51.000 --> 00:38:54.000
13, 21, and 23.

00:38:54.000 --> 00:38:58.000
This sequence is created by simply for each term,

00:38:58.000 --> 00:39:04.000
in other words for the second term here, adding the two terms,

00:39:04.000 --> 00:39:07.000
the fourth, the zeroth, and the first term.

00:39:07.000 --> 00:39:10.000
We usually index these according to zero.

00:39:10.000 --> 00:39:13.000
You may have seen the Fibonacci sequence starting with 1, 1.

00:39:13.000 --> 00:39:17.000
That's perfectly fine. We're just starting at a different place.

00:39:17.000 --> 00:39:22.000
But the point is each term is a sum of the two preceding terms.

00:39:22.000 --> 00:39:27.000
So you can solve this recursively by using a function like this.

00:39:27.000 --> 00:39:29.000
Here's the Fibonacci sequence.

00:39:29.000 --> 00:39:37.000
If n is less than 2, in other words if it's 1 or 0, we return n, 0 or 1.

00:39:37.000 --> 00:39:40.000
Otherwise we return the sum of the previous two

00:39:40.000 --> 00:39:44.000
by calling the Fibonacci function recursively again.

00:39:44.000 --> 00:39:48.000
So notice each time I call this function I'm calling it twice.

00:39:48.000 --> 00:39:52.000
Now it turns out that that is very, very inefficient.

00:39:52.000 --> 00:39:57.000
So each time we increase the number from Fibonacci 6 to Fibonacci 7,

00:39:57.000 --> 00:40:03.000
we take this whole tree of recursive calls and double it.

00:40:03.000 --> 00:40:07.000
And so this is called an exponential explosion.

00:40:07.000 --> 00:40:13.000
And we can fix this also with a helper function

00:40:13.000 --> 00:40:16.000
and turning Fib into a wrapper.

00:40:16.000 --> 00:40:22.000
So let's look at our last exercise here.

00:40:22.000 --> 00:40:26.000
So this is E.

00:40:26.000 --> 00:40:32.000
And we're going to look at efficiency.

00:40:32.000 --> 00:40:39.000
And so what I've done here is I've created two versions of the Fibonacci sequence.

00:40:39.000 --> 00:40:42.000
Both of these are the same as the ones I had on the slide.

00:40:42.000 --> 00:40:45.000
So they're both identical now.

00:40:45.000 --> 00:40:49.000
And we're going to modify this to see if it's faster.

00:40:49.000 --> 00:40:56.000
What the main function does is it simply uses some of the C++11 timekeeping functions

00:40:56.000 --> 00:41:02.000
to see how many nanoseconds it takes to compute this Fibonacci number.

00:41:02.000 --> 00:41:10.000
So I'm calling Fibonacci 10, then 25, then 35, then 45.

00:41:10.000 --> 00:41:13.000
So let's go ahead and get a terminal on this.

00:41:13.000 --> 00:41:17.000
I didn't create a terminal before I did that.

00:41:17.000 --> 00:41:21.000
So let's open an integrated terminal on that.

00:41:21.000 --> 00:41:27.000
Let's maximize this and let's do make run.

00:41:27.000 --> 00:41:30.000
So you can see it's pretty fast for the first couple, right?

00:41:30.000 --> 00:41:34.000
Although 25 and 35 took a few seconds.

00:41:34.000 --> 00:41:41.000
So 5,200 nanoseconds for 10 to 2,000.

00:41:41.000 --> 00:41:45.000
So that's because the code is already in memory.

00:41:45.000 --> 00:41:48.000
We say it's cached when we call it again.

00:41:48.000 --> 00:41:51.000
So notice it was much less time.

00:41:51.000 --> 00:42:02.000
But when we go increase the time by 10, we go from 2,000 to 5,000 to about a million.

00:42:02.000 --> 00:42:04.000
And so both these are about a million.

00:42:04.000 --> 00:42:07.000
One's 600,000 and one's 800,000.

00:42:07.000 --> 00:42:09.000
And when we increase it only 10 more.

00:42:09.000 --> 00:42:13.000
So I increased it 15 and went up to a million nanoseconds.

00:42:13.000 --> 00:42:20.000
Now I've got about 195 million nanoseconds,

00:42:20.000 --> 00:42:25.000
195 million nanoseconds versus 1 million.

00:42:25.000 --> 00:42:29.000
So that's quite a change to increase by 10.

00:42:29.000 --> 00:42:34.000
And when I increase it 10 more, I go up to, let's see,

00:42:34.000 --> 00:42:44.000
there's thousands, hundreds of thousands, millions, up to about 23, 24 billion times.

00:42:44.000 --> 00:42:51.000
So you can see this exponential explosion of adding additional function calls.

00:42:51.000 --> 00:42:54.000
So let's see how we would solve that.

00:42:54.000 --> 00:42:58.000
Let's see how we would fix that.

00:42:58.000 --> 00:43:04.000
And the solution is to avoid making these additional functional calls.

00:43:04.000 --> 00:43:07.000
And so we'll write a function here.

00:43:07.000 --> 00:43:10.000
We'll call it helper.

00:43:10.000 --> 00:43:14.000
It's going to take the number n.

00:43:14.000 --> 00:43:21.000
And it's going to remember when we call the function what the previous two were.

00:43:21.000 --> 00:43:24.000
And so I'm going to call these int t0.

00:43:24.000 --> 00:43:27.000
And I'm going to call this one int t1.

00:43:27.000 --> 00:43:32.000
For term 0 and term 1.

00:43:32.000 --> 00:43:36.000
Now we have two possibilities here.

00:43:36.000 --> 00:43:46.000
If n equals 0, we're going to return whatever term 0 was.

00:43:46.000 --> 00:43:54.000
If n is 1, we're going to return whatever t1 is.

00:43:54.000 --> 00:44:02.000
If it's neither of those, we're simply going to return the helper.

00:44:02.000 --> 00:44:06.000
With n minus 1, a smaller n.

00:44:06.000 --> 00:44:11.000
Instead of t0, we're going to change t0 to t1.

00:44:11.000 --> 00:44:14.000
In other words, we're going to add those together.

00:44:14.000 --> 00:44:20.000
And t1 is going to become t1 plus t0.

00:44:20.000 --> 00:44:25.000
So notice how we're remembering what happens each time we call.

00:44:25.000 --> 00:44:31.000
So we don't have to go back down and find out what the previous one is.

00:44:31.000 --> 00:44:33.000
So this is our helper.

00:44:33.000 --> 00:44:36.000
This is going to be our wrapper.

00:44:36.000 --> 00:44:45.000
And what we're going to do with our wrapper is we're going to return helper with n.

00:44:45.000 --> 00:44:49.000
And we're going to put in what our t0 and t1 is.

00:44:49.000 --> 00:44:52.000
And our t0 here is going to be 0.

00:44:52.000 --> 00:44:55.000
And our t1 is going to be 1.

00:44:55.000 --> 00:45:02.000
The beginning of the sequence for the Fibonacci sequence.

00:45:02.000 --> 00:45:05.000
Okay, so let's try that again.

00:45:05.000 --> 00:45:13.000
Now, notice fib is going to take just as long as it did before.

00:45:13.000 --> 00:45:20.000
But fib2 is going to take almost no time at all.

00:45:20.000 --> 00:45:22.000
Almost no time at all.

00:45:22.000 --> 00:45:25.000
Even 35. Look at the difference between 35.

00:45:25.000 --> 00:45:35.000
Now, 45 for fib is still going to take our 25 billion nanoseconds.

00:45:35.000 --> 00:45:37.000
So roughly 25 seconds, right?

00:45:37.000 --> 00:45:39.000
24, 25 seconds.

00:45:39.000 --> 00:45:43.000
Okay, so it again took 24, 25 seconds.

00:45:43.000 --> 00:45:49.000
And again, when we did it with the helper, fib2, it was almost instantaneous.

00:45:49.000 --> 00:45:55.000
So recursive functions are not inherently inefficient.

00:45:55.000 --> 00:45:59.000
But you have to think about what function calls are being made

00:45:59.000 --> 00:46:08.000
and what data structures are being created when you do this.

00:46:08.000 --> 00:46:11.000
Okay, so you have enough stuff to turn in your exercises.

00:46:11.000 --> 00:46:19.000
And I will see you back here for lecture 11.

00:46:19.000 --> 00:46:21.000
[END]


WEBVTT

00:00:00.000 --> 00:00:10.000
Hello everyone, this is Steve Gilbert. Welcome to lecture 15 on user-defined data types.

00:00:10.000 --> 00:00:18.000
We're going to start out today by doing a little stream review.

00:00:18.000 --> 00:00:23.000
We're going to read a text file that contains star information.

00:00:23.000 --> 00:00:30.000
This is a star catalog. And so we're going to open and read the input file.

00:00:30.000 --> 00:00:38.000
And so we're going to look at stars.txt. Now in the input file, we'll see several different values.

00:00:38.000 --> 00:00:49.000
Let's just go ahead and do that right now. So we're in lecture 15 and I have opened the starcat.cpp here.

00:00:49.000 --> 00:01:01.000
I'm going to put my name on it. And I'm also going to open up stars.txt so I can see the data file that I'm reading.

00:01:01.000 --> 00:01:08.000
So you notice that I have three doubles starting each line of text.

00:01:08.000 --> 00:01:16.000
And those represent the location in space of that particular star.

00:01:16.000 --> 00:01:22.000
That number is followed by an integer, 28 here in this first case.

00:01:22.000 --> 00:01:29.000
This is called the Draper number. The Draper number. What it is, it's a catalog identifier.

00:01:29.000 --> 00:01:37.000
In a star catalog, kind of like the Dewey Decimal number you'd have on a book in the library.

00:01:37.000 --> 00:01:44.000
Following that, we have a third double. Let me go take a look right here.

00:01:44.000 --> 00:01:51.000
4.61. And this represents the magnitude or brightness of the star.

00:01:51.000 --> 00:01:56.000
Following that, we have another identifier, that integer 3.

00:01:56.000 --> 00:02:02.000
And that represents a different catalog number in a catalog called the Harvard catalog.

00:02:02.000 --> 00:02:06.000
So this number is called the Harvard Revised number.

00:02:06.000 --> 00:02:17.000
Now some stars, like this star on line 6, and this star on line 7, have a string at the end of it. Some kind of name.

00:02:17.000 --> 00:02:23.000
Those are what we call the name stars. If you scroll through them, you may recognize some of the stars.

00:02:23.000 --> 00:02:31.000
Let's see if I can find one I recognize. I don't actually recognize any of those names.

00:02:31.000 --> 00:02:35.000
Here's Polaris. I recognize the North star.

00:02:35.000 --> 00:02:39.000
Now the stars that have a name may actually have two names.

00:02:39.000 --> 00:02:45.000
They may have a Latin name and a common name and so forth.

00:02:45.000 --> 00:02:53.000
Or they may just have a common name. And if they have two names, the first name is ended with a semicolon, like that.

00:02:53.000 --> 00:03:11.000
So our job here today is to read the stars and print only the name stars. Print the primary name, a comma, an X and a Y in space.

00:03:11.000 --> 00:03:15.000
We're going to skip the Z and the magnitude.

00:03:15.000 --> 00:03:21.000
So let's go ahead and do that.

00:03:21.000 --> 00:03:31.000
So let's go to StarCat. As I mentioned, you want to put your name. And I'm going to move that over there just to kind of clear up the screen.

00:03:31.000 --> 00:03:35.000
So the catalog number is coming in as a string and we want to open it.

00:03:35.000 --> 00:03:39.000
We've included fstream here so we know how to open file streams.

00:03:39.000 --> 00:03:46.000
So we're going to create an input file stream. And I have stream. I'll call it in.

00:03:46.000 --> 00:03:50.000
And I'm going to open it with cat name.

00:03:50.000 --> 00:03:56.000
Now, if we can't open the file, then we want to print an error message and exit.

00:03:56.000 --> 00:04:17.000
So if in fail, CR cannot open cat name, capital N on cat name.

00:04:17.000 --> 00:04:25.000
And since this is a void function, I'm just going to return.

00:04:25.000 --> 00:04:41.000
Ok, now let's read the file. So basically, notice that every line has X, Y, Z, a Draper number, a magnitude, and a Harvard number.

00:04:41.000 --> 00:04:45.000
So that means I need to create variables for that, right?

00:04:45.000 --> 00:04:58.000
So I'm going to say double X, Y, Z, magnitude. Those are my four doubles.

00:04:58.000 --> 00:05:12.000
And Harvard and Draper. Or Draper and Harvard. Let me put them in the order they're in.

00:05:12.000 --> 00:05:17.000
And to read the file using streams, I just use formatted input.

00:05:17.000 --> 00:05:28.000
So while in X, Y, Z, Draper number's next, so make sure you don't put magnitude there.

00:05:28.000 --> 00:05:38.000
Then the magnitude. And then the Harvard number.

00:05:38.000 --> 00:05:43.000
Ok, well that's true.

00:05:43.000 --> 00:05:52.000
So this will process some of the file. So let's go to the top of this text file.

00:05:52.000 --> 00:05:55.000
So that would process that line.

00:05:55.000 --> 00:06:01.000
And then, when we read the next line, that would process it. That would process the next line.

00:06:01.000 --> 00:06:05.000
That would process this amount of data in line six.

00:06:05.000 --> 00:06:11.000
But when we came around again, this is what it would read for X.

00:06:11.000 --> 00:06:16.000
And what would happen when it tried to read that? It would stop working.

00:06:16.000 --> 00:06:24.000
So we have to see if there's any extra text at the end of each line.

00:06:24.000 --> 00:06:32.000
So after we've read the numbers off from the line, we're going to have to create a variable.

00:06:32.000 --> 00:06:37.000
So string line. I'll call it rest.

00:06:37.000 --> 00:06:45.000
So string rest and get line in rest.

00:06:45.000 --> 00:06:52.000
So when we finish reading this first line, we've read the three,

00:06:52.000 --> 00:06:59.000
there is still an invisible new line sitting out here waiting to be read.

00:06:59.000 --> 00:07:03.000
And we haven't displayed that yet.

00:07:03.000 --> 00:07:08.000
We could turn on with the editor. I'm sure there's a way to display these hidden files.

00:07:08.000 --> 00:07:10.000
I'm not displaying them right now.

00:07:10.000 --> 00:07:12.000
But there's a new line.

00:07:12.000 --> 00:07:19.000
And so get line reads everything up to, including the new line, to clear off to go to the next line.

00:07:19.000 --> 00:07:25.000
Now that's not important if we don't have a string, but if it is a string, we want to read that.

00:07:25.000 --> 00:07:32.000
Alpha Hertz or cath semicolon space casp beta.

00:07:32.000 --> 00:07:45.000
And so what we want to do now is after we've read the rest of the line, we want to see if it's if it's not empty.

00:07:45.000 --> 00:07:58.000
So if rest if not rest empty.

00:07:58.000 --> 00:08:09.000
That means I have a first name, a name one and possibly a name to possibly a name to.

00:08:09.000 --> 00:08:15.000
So we're going to need to use those. Actually, I'm going to use them only inside here.

00:08:15.000 --> 00:08:22.000
So let me move that down here.

00:08:22.000 --> 00:08:31.000
So because I'm only going to print the name stars, which means that I only need to print inside this if statement.

00:08:31.000 --> 00:08:36.000
If it's if it's not a name star, I'm not going to print it.

00:08:36.000 --> 00:08:44.000
So let me create a couple of variables. String name one, name two.

00:08:44.000 --> 00:08:56.000
Let me find out if there's a semicolon. So size T pause or auto pause equals rest.

00:08:56.000 --> 00:09:02.000
Find a semicolon.

00:09:02.000 --> 00:09:08.000
Now, two possibilities. One possibility is that it is set to string in pause.

00:09:08.000 --> 00:09:15.000
So if pause is equal to string colon colon and pause.

00:09:15.000 --> 00:09:21.000
In other words, it wasn't found. That means we have one name.

00:09:21.000 --> 00:09:29.000
So name one equals rest substring.

00:09:29.000 --> 00:09:39.000
Why? Why substring one? Because in this case where I have one, notice when I do get line, that'll be space alpha hertz.

00:09:39.000 --> 00:09:46.000
Right. Because there's always a space at the end of the Harvard number.

00:09:46.000 --> 00:09:52.000
And so name two will just be the empty string.

00:09:52.000 --> 00:10:08.000
If that's not the case, I have two names. So name one equals rest substring starting at position one and going up to pause.

00:10:08.000 --> 00:10:22.000
And name two equals rest substring starting at pause plus one.

00:10:22.000 --> 00:10:27.000
No, no, actually starting at pause plus two. If we started at pause plus one.

00:10:27.000 --> 00:10:33.000
So here's pause, right? We started at pause plus one. I'd have a space in front of the second name.

00:10:33.000 --> 00:10:42.000
And I don't want that. So I'm starting at pause plus two. So I only have CAS beta inside there.

00:10:42.000 --> 00:10:50.000
OK, so we know that this is extracted the name part of it. Now we're going to print the primary name. Name one.

00:10:50.000 --> 00:10:53.000
X and a Y and the magnitude.

00:10:53.000 --> 00:11:06.000
So I'm going to say C out. Name one. Comma space parenthesis.

00:11:06.000 --> 00:11:17.000
X comma space or comma space. Y.

00:11:17.000 --> 00:11:29.000
Right print. A comma, a space and the magnitude.

00:11:29.000 --> 00:11:36.000
Print a new line. We might want to bring that down to two lines.

00:11:36.000 --> 00:11:41.000
I don't know where you want to split it. Maybe right there.

00:11:41.000 --> 00:11:45.000
Maybe that'll look a little bit better.

00:11:45.000 --> 00:11:51.000
Now if we do make run, it'll just call our function star cat and pass in stars dot text.

00:11:51.000 --> 00:11:55.000
So let's just do alt L.

00:11:55.000 --> 00:12:06.000
Oh, you can't do alt L. This is the new version of the IDE. So we have to come over here to A, open a terminal there.

00:12:06.000 --> 00:12:11.000
And then let's go ahead and do make run.

00:12:11.000 --> 00:12:24.000
And here we have the name. We've read the entire catalog of stars. We have the name, X, Y and the magnitude of each of those stars.

00:12:24.000 --> 00:12:31.000
So make run just does it all. Make test tests to make sure that you've actually done it correctly.

00:12:31.000 --> 00:12:35.000
So if we do make test.

00:12:35.000 --> 00:12:43.000
Notice that it will test several different things. It looks like make test, some of them are failing.

00:12:43.000 --> 00:13:00.000
So if we read that. If you read O zero. Oh, it looks like we're actually getting a semicolon after our name.

00:13:00.000 --> 00:13:10.000
OK, for some of those stars that have two names. So we have some debugging to do on that.

00:13:10.000 --> 00:13:16.000
So name one, pause.

00:13:16.000 --> 00:13:29.000
Does this look like pause minus one?

00:13:29.000 --> 00:13:38.000
I think it does, because if we want to pause, we're not counting for the fact that we're starting here from one.

00:13:38.000 --> 00:13:45.000
So that's what testing is for, to make sure that you got all of them correct.

00:13:45.000 --> 00:13:52.000
And I have some inputs here that in fact should have been Polaris, but in fact was Polaris semicolon.

00:13:52.000 --> 00:13:58.000
Should have been Ruchba, in fact was Ruchba with a semicolon.

00:13:58.000 --> 00:14:05.000
Let's try it again.

00:14:05.000 --> 00:14:17.000
OK, so that passes all of the tests. That looks OK.

00:14:17.000 --> 00:14:24.000
All right, so let's go on now and get to today's topic.

00:14:24.000 --> 00:14:38.000
So what we have here is each line in stars.txt consists of related information, related information.

00:14:38.000 --> 00:14:47.000
The X and the Y and the Z about one particular star.

00:14:47.000 --> 00:14:56.000
And just to print out that data, variables work fine. But what if I wanted to gather up all the information about a star

00:14:56.000 --> 00:15:04.000
and pass it to a bunch of functions that would analyze different characteristics of those stars?

00:15:04.000 --> 00:15:08.000
Well, simple variables aren't flexible enough for this.

00:15:08.000 --> 00:15:19.000
What we need is we need a way to package up all the parts into some kind of more complex structured data of different types.

00:15:19.000 --> 00:15:29.000
So in computer science and in programming languages, we call such structured types records.

00:15:29.000 --> 00:15:39.000
And in C++, records are called structures or the keyword is struct we'll use to create them.

00:15:39.000 --> 00:15:52.000
So basically, it's just a collection of data where each collection represents one item of a particular user defined kind, like a star in this case.

00:15:52.000 --> 00:16:06.000
We say that the data is heterogeneous, meaning that we can have integers and strings and doubles all together wrapped up in one record.

00:16:06.000 --> 00:16:11.000
It doesn't need to be all of the same type like an array does.

00:16:11.000 --> 00:16:17.000
We say that it's accessible, meaning that we can directly access each of the parts.

00:16:17.000 --> 00:16:22.000
So here's the syntax for creating a structure definition.

00:16:22.000 --> 00:16:25.000
It's the keyword struct instead of class.

00:16:25.000 --> 00:16:36.000
The name of the struct, which we call formally a structure tag, but other than me formally telling you this, we'll just call it the structure name.

00:16:36.000 --> 00:16:40.000
Inside the structure, we have named members.

00:16:40.000 --> 00:16:47.000
So members are like variable definitions, but they're not actually variable definitions.

00:16:47.000 --> 00:16:49.000
They're potential variable definitions.

00:16:49.000 --> 00:16:54.000
So notice I've named one PID, the person ID.

00:16:54.000 --> 00:16:57.000
I've named one name.

00:16:57.000 --> 00:16:59.000
I've named one DOB.

00:16:59.000 --> 00:17:06.000
And notice that the structures can be the built-in types, library types, or other structured types.

00:17:06.000 --> 00:17:16.000
Now this might look like creating a class in Java and adding data members or adding instance variables.

00:17:16.000 --> 00:17:18.000
It's very, very similar.

00:17:18.000 --> 00:17:24.000
We don't use the keywords public or private here in front of the things like you would do in Java.

00:17:24.000 --> 00:17:28.000
But there's one difference that's going to trip you up.

00:17:28.000 --> 00:17:36.000
That difference is in C++, we always need to put a semicolon at the end of the structure definition.

00:17:36.000 --> 00:17:42.000
In Java you don't. In C++ you must.

00:17:42.000 --> 00:17:47.000
Now, structures are a new user-defined type.

00:17:47.000 --> 00:17:49.000
They're a definition.

00:17:49.000 --> 00:17:51.000
They're a definition for a type.

00:17:51.000 --> 00:17:55.000
They're not a definition for a variable.

00:17:55.000 --> 00:18:02.000
So since they're a definition for a type, we usually place that definition in a header file.

00:18:02.000 --> 00:18:04.000
Now there's a problem though.

00:18:04.000 --> 00:18:07.000
What if that header file was included twice?

00:18:07.000 --> 00:18:12.000
It's an error if the definition is included twice, is seen twice.

00:18:12.000 --> 00:18:14.000
Your code will not compile.

00:18:14.000 --> 00:18:19.000
And so just like we did with functions, we'll use header guards to prevent that.

00:18:19.000 --> 00:18:25.000
So let's go ahead and add our structure definition to stars.h.

00:18:25.000 --> 00:18:28.000
And this is the definition I'm going to use.

00:18:28.000 --> 00:18:33.000
Struct star. I'm going to put all my doubles together just like I had them in the file.

00:18:33.000 --> 00:18:36.000
My two integers together and my two strings.

00:18:36.000 --> 00:18:44.000
So all of this data will store the data about one star.

00:18:44.000 --> 00:18:49.000
So we're simply going to change this program.

00:18:49.000 --> 00:18:57.000
We're going to add the structure definition in stars.h.

00:18:57.000 --> 00:19:02.000
So I'm going to say struct star.

00:19:02.000 --> 00:19:08.000
I'm going to open and close it and put the semicolon on all at once so I don't forget it.

00:19:08.000 --> 00:19:25.000
I'm going to add the data members, so double, x, y, z, magnitude, int draper, Harvard,

00:19:25.000 --> 00:19:35.000
and standard string, name one and name two.

00:19:35.000 --> 00:19:39.000
So notice my header file already includes this.

00:19:39.000 --> 00:19:44.000
And remember in a header file we cannot use using namespace standard.

00:19:44.000 --> 00:19:49.000
So for a structure, if you want to use a type, just like for a prototype in header file,

00:19:49.000 --> 00:19:54.000
you have to fully qualify the library type.

00:19:54.000 --> 00:19:58.000
So there is our star structure.

00:19:58.000 --> 00:20:02.000
What can we do with that star structure?

00:20:02.000 --> 00:20:06.000
Well, what we can do is we can create variables of that type.

00:20:06.000 --> 00:20:11.000
So if you have a type, its purpose is to create variables.

00:20:11.000 --> 00:20:13.000
These are called structure variables.

00:20:13.000 --> 00:20:18.000
Like primitive types, such variables are uninitialized.

00:20:18.000 --> 00:20:26.000
So star a and b, both of them would be star objects with x, y, z, and so forth.

00:20:26.000 --> 00:20:32.000
But x, y, z, and all the other members would be set to random numbers.

00:20:32.000 --> 00:20:36.000
The two names, name one and name two, would be okay.

00:20:36.000 --> 00:20:39.000
They'd be the empty string.

00:20:39.000 --> 00:20:43.000
So you can initialize such a variable in several ways.

00:20:43.000 --> 00:20:46.000
One, you can give it the default value.

00:20:46.000 --> 00:20:51.000
So just when you create the variable, put the curly braces after it,

00:20:51.000 --> 00:20:53.000
and that will default initialize it.

00:20:53.000 --> 00:21:00.000
In other words, all the x's and y's will be zero.

00:21:00.000 --> 00:21:07.000
You can aggregate initialize it, meaning you supply a value for each of the data members.

00:21:07.000 --> 00:21:22.000
So in this case, x is .873, y is .032, z is .486, magnitude is 2.07.

00:21:22.000 --> 00:21:30.000
The Draper number is .358, the Harvard number is 15, name one is Rigel, name two is Beta.

00:21:30.000 --> 00:21:41.000
Now, notice that the order that you put the data members depends on the order that the data members are defined in the structure.

00:21:41.000 --> 00:21:45.000
Notice that this order is different than what we read the data in.

00:21:45.000 --> 00:21:49.000
Notice that we read x, y, z, then the Draper number,

00:21:49.000 --> 00:21:57.000
but in the structure we put the x, y, z and the magnitude all together.

00:21:57.000 --> 00:22:01.000
And so that's the way you have to initialize it.

00:22:01.000 --> 00:22:03.000
Finally, we can initialize it one third way.

00:22:03.000 --> 00:22:09.000
If we have another star, we can either assign to it or we can copy initialize it.

00:22:09.000 --> 00:22:20.000
In other words, I can create a star E and it will have the same values that star C has.

00:22:20.000 --> 00:22:27.000
Now, structures can contain other structures, so if we create some useful, say, utility structures,

00:22:27.000 --> 00:22:35.000
a point 3D that has x, y, and z, a names structure that contained a couple of names,

00:22:35.000 --> 00:22:43.000
and a catalog structure that contained two catalogs, we could then use these structures inside another structure.

00:22:43.000 --> 00:22:47.000
We could nest them and we could define our star like this.

00:22:47.000 --> 00:22:51.000
So, this might be a little bit more readable.

00:22:51.000 --> 00:22:57.000
You can see what those x, y, and z represent, the location, then the magnitude,

00:22:57.000 --> 00:23:03.000
then the catalog numbers, and then the names of the stars.

00:23:03.000 --> 00:23:08.000
So, this might be a little bit more readable.

00:23:08.000 --> 00:23:14.000
Now, to access the data members, we simply use the dot operator,

00:23:14.000 --> 00:23:20.000
very similar to what you do in Java if you had a public instance variable.

00:23:20.000 --> 00:23:29.000
So, if I want to access the name in the structure variable A, I just say a.name1 or a.name2.

00:23:29.000 --> 00:23:35.000
You can also print it out, of course. So, just the name of the structure variable,

00:23:35.000 --> 00:23:41.000
and then the name of the data member inside the structure variable.

00:23:41.000 --> 00:23:44.000
For a nested structure, you just keep adding dots.

00:23:44.000 --> 00:23:51.000
So, you remember I created a structure, a different star structure that had a location in it.

00:23:51.000 --> 00:24:00.000
So, s.location would bring back a .3D structure, and then I'd select x out of it.

00:24:00.000 --> 00:24:08.000
So, I'm selecting members from a structure using the dot, the member selection operator.

00:24:08.000 --> 00:24:13.000
You can also assign and copy entire structure variables.

00:24:13.000 --> 00:24:18.000
You cannot compare them. You can assign them and copy them.

00:24:18.000 --> 00:24:25.000
So, let's go ahead and modify our star cat to use our structure variable

00:24:25.000 --> 00:24:31.000
instead of the individual variables we used before.

00:24:31.000 --> 00:24:34.000
So, let's come back to star cat.

00:24:34.000 --> 00:24:44.000
First, let's come up here and say I want to include stars.h.

00:24:44.000 --> 00:24:51.000
Notice now my program knows about the user defined type.

00:24:51.000 --> 00:25:03.000
So, instead of these variables on line 21 and 22, I can create a star variable.

00:25:03.000 --> 00:25:10.000
So, I can say star s.

00:25:10.000 --> 00:25:17.000
So, I no longer have individual variables. I have them grouped together in this record.

00:25:17.000 --> 00:25:23.000
Now, when I read them, these parts, these members are inside the variable s.

00:25:23.000 --> 00:25:37.000
So, I'd say sx, sy, sz, sdraper, smagnitude, and sharper.

00:25:37.000 --> 00:25:53.000
Now, notice that when I do this, these are in the order that the members are defined inside the stars.txt file,

00:25:53.000 --> 00:25:56.000
not the order they're defined inside the structure.

00:25:56.000 --> 00:26:02.000
So, this extracts it from the text file and puts it in the structure.

00:26:02.000 --> 00:26:08.000
So, even though x, y, z, and magnitude are together, we don't read the magnitude before the draper number

00:26:08.000 --> 00:26:12.000
because in the text file, the draper number appears first.

00:26:12.000 --> 00:26:16.000
So, we're going to get the rest from the file.

00:26:16.000 --> 00:26:22.000
And if it's not empty, so first, notice we have a name1 and name2,

00:26:22.000 --> 00:26:26.000
but we want to make sure that every time we come through here,

00:26:26.000 --> 00:26:29.000
since I'm not reading into name1 and name2,

00:26:29.000 --> 00:26:34.000
every time I come through here, I reset name1 and name2.

00:26:34.000 --> 00:26:47.000
So, s.name1 = s.name2, and both of those are going to be equal to the empty string.

00:26:47.000 --> 00:26:55.000
Okay, so I no longer need this line on line 32, right there, name1 and name2.

00:26:55.000 --> 00:27:04.000
And so, I'm going to say if I find this semicolon, then s.name1 is that,

00:27:04.000 --> 00:27:09.000
and s.name1 and s.name2.

00:27:09.000 --> 00:27:21.000
And when I print them out, finally, I'm printing out s.name1, s.x,

00:27:21.000 --> 00:27:28.000
s.y, and s.magnitude.

00:27:28.000 --> 00:27:36.000
Okay, so let's try that out.

00:27:36.000 --> 00:27:42.000
And all we're going to do is do make test again.

00:27:42.000 --> 00:27:46.000
Okay, and we still got 100%, so in this case,

00:27:46.000 --> 00:27:50.000
we're not using the individual variables.

00:27:50.000 --> 00:27:56.000
We have encapsulated all of the variables into this single star object right here,

00:27:56.000 --> 00:27:59.000
this single star.

00:27:59.000 --> 00:28:03.000
Now, probably most of you are thinking, "Well, yeah, so what?

00:28:03.000 --> 00:28:05.000
That didn't seem any better."

00:28:05.000 --> 00:28:09.000
But now that we've encapsulated the data inside the structure,

00:28:09.000 --> 00:28:16.000
we can write functions that take and produce structure variables.

00:28:16.000 --> 00:28:19.000
And so that's our next step.

00:28:19.000 --> 00:28:26.000
So for our next step, what we want to do is write functions that take structures.

00:28:26.000 --> 00:28:29.000
Now, in the C language, where structures were developed,

00:28:29.000 --> 00:28:32.000
they were known as second-class types.

00:28:32.000 --> 00:28:37.000
That's because they don't always act the same way as the built-in types.

00:28:37.000 --> 00:28:39.000
The built-in types are the natives.

00:28:39.000 --> 00:28:46.000
The second-class types don't have all the features of the built-in types.

00:28:46.000 --> 00:28:50.000
So if A and B are structure variables, say stars,

00:28:50.000 --> 00:28:54.000
this would be illegal if A and B are structure types.

00:28:54.000 --> 00:28:57.000
But the built-in types get to do this.

00:28:57.000 --> 00:29:04.000
And so we can fix this by writing functions to supply the missing operations.

00:29:04.000 --> 00:29:11.000
So I could write a method called equals, and I could say if equal A, B,

00:29:11.000 --> 00:29:16.000
and get back true and false, and use that instead.

00:29:16.000 --> 00:29:20.000
So we can pass structure variables to functions.

00:29:20.000 --> 00:29:24.000
We can also write a function that returns a structure.

00:29:24.000 --> 00:29:30.000
We're going to use the same rules for variable passing as for strings.

00:29:30.000 --> 00:29:35.000
So structure types we're going to pass by reference or const reference.

00:29:35.000 --> 00:29:39.000
We'll never pass structure types by value.

00:29:39.000 --> 00:29:45.000
So if I wanted to write my equal function that I would use in place of this,

00:29:45.000 --> 00:29:53.000
that the first-class types do, I'd pass a const string ref A and a const string ref B.

00:29:53.000 --> 00:29:58.000
And if they were equal, I'd return true in that case.

00:29:58.000 --> 00:30:01.000
So we're going to do that.

00:30:01.000 --> 00:30:07.000
We're going to write some functions to print and read star objects.

00:30:07.000 --> 00:30:14.000
And so my print function is going to take the stream that I'm going to read from,

00:30:14.000 --> 00:30:21.000
and a write to, and a star that I'm going to display.

00:30:21.000 --> 00:30:25.000
And it's going to return the stream after it's done.

00:30:25.000 --> 00:30:30.000
And my read function is going to take the stream I'm going to read from,

00:30:30.000 --> 00:30:36.000
and a star by reference that I'm going to fill in when I read.

00:30:36.000 --> 00:30:43.000
Now, notice the functions are returning the modified stream so we can test it.

00:30:43.000 --> 00:30:46.000
In other words, I want to be able to do this.

00:30:46.000 --> 00:30:54.000
I want to say I have stream in stars.text, star.s, and I'll read in s.

00:30:54.000 --> 00:31:06.000
So for our next exercise, let's do in B, let's prototype and implement these two functions, print and read.

00:31:06.000 --> 00:31:14.000
Then we'll uncomment the first section of run and do make run.

00:31:14.000 --> 00:31:21.000
So let's close these.

00:31:21.000 --> 00:31:25.000
Let's open B.

00:31:25.000 --> 00:31:27.000
Let me right click it.

00:31:27.000 --> 00:31:30.000
Open it in the integrated terminal there.

00:31:30.000 --> 00:31:38.000
And we'll have stars.h and stars.cpp.

00:31:38.000 --> 00:31:47.000
Put your names in stars.cpp.

00:31:47.000 --> 00:31:53.000
And then in stars.h, notice I already have my struct star.

00:31:53.000 --> 00:31:56.000
I already have my struct star.

00:31:56.000 --> 00:31:59.000
I've included string and iostream.

00:31:59.000 --> 00:32:04.000
So let's just put in the prototypes for those two functions.

00:32:04.000 --> 00:32:09.000
So for my print function, it's an ostream ref.

00:32:09.000 --> 00:32:11.000
But I'm inside a header file.

00:32:11.000 --> 00:32:14.000
I can't use using namespace standard.

00:32:14.000 --> 00:32:17.000
So the compiler is not going to understand that.

00:32:17.000 --> 00:32:21.000
So I have to write standard colon ostream ref.

00:32:21.000 --> 00:32:23.000
Print is the name of the function.

00:32:23.000 --> 00:32:29.000
It's going to take a standard ostream ref for the output.

00:32:29.000 --> 00:32:41.000
And it's going to take a const star ref s for the star.

00:32:41.000 --> 00:32:46.000
And for our input, it's going to take a standard iostream ref.

00:32:46.000 --> 00:32:49.000
We're going to call the function read.

00:32:49.000 --> 00:32:58.000
I'm going to take an iostream ref in as my input stream.

00:32:58.000 --> 00:33:05.000
And this time I'm going to take a star by reference s.

00:33:05.000 --> 00:33:09.000
Okay, so there's my two prototypes.

00:33:09.000 --> 00:33:12.000
Let's copy the two prototypes.

00:33:12.000 --> 00:33:16.000
Let's move them over to stars.cpp.

00:33:16.000 --> 00:33:20.000
Let's put a body on it.

00:33:20.000 --> 00:33:25.000
Remove the semicolon.

00:33:25.000 --> 00:33:36.000
And let's return the output stream and the input stream.

00:33:36.000 --> 00:33:41.000
Okay, now I haven't done any reading or printing in here.

00:33:41.000 --> 00:33:47.000
So what do we need to do to read from output?

00:33:47.000 --> 00:33:51.000
Basically we need to do what we did back up in A.

00:33:51.000 --> 00:33:55.000
So notice I have a star here.

00:33:55.000 --> 00:33:59.000
Now I'm going to print it exactly like we printed it before.

00:33:59.000 --> 00:34:16.000
So I'm going to say out name one, comma, space.

00:34:16.000 --> 00:34:18.000
It's not name one, is it?

00:34:18.000 --> 00:34:21.000
It's s.name one.

00:34:21.000 --> 00:34:33.000
And s.x, a comma and a space, and s.y.

00:34:33.000 --> 00:34:40.000
And a closing parenthesis and a comma and a space.

00:34:40.000 --> 00:34:45.000
And s.magnitude.

00:34:45.000 --> 00:34:50.000
Now we don't want to use a new line like we did when we were printing it out ourselves.

00:34:50.000 --> 00:34:55.000
When you call the print function, they'll use the new line on it at that point.

00:34:55.000 --> 00:35:00.000
They'll use the new line on it at that point.

00:35:00.000 --> 00:35:04.000
Now to read the data, we have a star object here.

00:35:04.000 --> 00:35:07.000
I have start there, of course it should be a star.

00:35:07.000 --> 00:35:11.000
You can see the difference in the coloring here.

00:35:11.000 --> 00:35:16.000
And did I make that mistake over in the header file?

00:35:16.000 --> 00:35:17.000
Yeah, I did.

00:35:17.000 --> 00:35:25.000
So that should be a star, not a start.

00:35:25.000 --> 00:35:44.000
So to read, what we're going to do is we're going to say in s.x, s.y, s.z.

00:35:44.000 --> 00:35:48.000
Even though we're not printing z, we still need to read it.

00:35:48.000 --> 00:36:02.000
s.draper, s.magnitude, and s.harvard.

00:36:02.000 --> 00:36:07.000
We need to set the name one and name two to nothing.

00:36:07.000 --> 00:36:17.000
So s.name1 equals s.name2 equals the empty string.

00:36:17.000 --> 00:36:22.000
Then we need to put exactly the same code we had before.

00:36:22.000 --> 00:36:32.000
So if we need to read, we need to do git line in.

00:36:32.000 --> 00:36:46.000
We need to create a string, I'll call it name.

00:36:46.000 --> 00:36:52.000
So now if that name has something in it, we need to transfer it to our strings.

00:36:52.000 --> 00:37:00.000
So if not name empty, or let me write it the other way, it's probably more easier for you.

00:37:00.000 --> 00:37:18.000
So if name not equal to that, the name's not empty, we're going to say auto pause equals name find.

00:37:18.000 --> 00:37:24.000
Notice this time we used double quotes, you can use double quotes or single quotes there.

00:37:24.000 --> 00:37:47.000
So if pause equals equals string end pause, if it's not found, that means we only have one name.

00:37:47.000 --> 00:37:52.000
So if pause equals equals end pause, it means we only have one name.

00:37:52.000 --> 00:38:02.000
So, and I think I did this wrong in the last exercise we did in A.

00:38:02.000 --> 00:38:16.000
So I'm going to say s.name1 equals name substring.

00:38:16.000 --> 00:38:29.000
Let's put that up here so it's a little easier to read.

00:38:29.000 --> 00:38:47.000
And if that's not the case, name1 equals name substring1 and pause minus 1.

00:38:47.000 --> 00:38:51.000
Again, to count for the space at the beginning of it.

00:38:51.000 --> 00:38:59.000
And whenever I have two lines, I don't like to put two statements on one line.

00:38:59.000 --> 00:39:05.000
I only use one line here when I can fit the whole thing on the side there.

00:39:05.000 --> 00:39:19.000
So name2 equals name substring pause plus 2.

00:39:19.000 --> 00:39:21.000
And we're going to return in.

00:39:21.000 --> 00:39:33.000
So let's come down here and let's uncomment part 1 here.

00:39:33.000 --> 00:39:39.000
So notice we're opening stars.txt, we're creating a star, and we're calling the read function.

00:39:39.000 --> 00:39:49.000
While read in, if not name empty and s magnitude greater than 6, print cout s.

00:39:49.000 --> 00:39:51.000
And we're printing an end out at the end of that.

00:39:51.000 --> 00:40:04.000
So notice that this is, this code right here, is almost the same thing as star cat that we did in part A.

00:40:04.000 --> 00:40:12.000
In other words, because we have functions now, we've been able to compress it down to these two pieces.

00:40:12.000 --> 00:40:19.000
And so it's much easier to read, much more flexible, much easier to use.

00:40:19.000 --> 00:40:29.000
So let's try that. Let's do make run.

00:40:29.000 --> 00:40:34.000
Okay, so name1, so I have a syntax error there, and name2.

00:40:34.000 --> 00:40:38.000
And of course, that's because this is not name1, right?

00:40:38.000 --> 00:40:50.000
It's s.name1 and s.name2.

00:40:50.000 --> 00:40:53.000
Let me clear it and run it again.

00:40:53.000 --> 00:41:00.000
Okay, so these are all the stars that are named that have a magnitude greater than 6.

00:41:00.000 --> 00:41:09.000
So again, writing functions, you can see how easy it is to use them after you've written the function.

00:41:09.000 --> 00:41:16.000
And how easy it is to use it after you've written the function.

00:41:16.000 --> 00:41:28.000
Now, it would be nicer if we could use the regular operators for our output.

00:41:28.000 --> 00:41:36.000
In other words, if there was no difference between a star and printing an int, that's what we're shooting for.

00:41:36.000 --> 00:41:44.000
And so for any user-defined type, you can overload most of the C++ operators to work with that type.

00:41:44.000 --> 00:41:48.000
So we're going to be covering this many, many times in this class.

00:41:48.000 --> 00:41:51.000
This is your first introduction to it.

00:41:51.000 --> 00:41:58.000
So, plus, equals, equals, greater than, all of those are called binary operators.

00:41:58.000 --> 00:42:06.000
Because we have a plus b, the operator plus takes two operands, the a and the b.

00:42:06.000 --> 00:42:09.000
One's on the left-hand side, one's on the right-hand side.

00:42:09.000 --> 00:42:13.000
The same through equals, equals, greater than, and so forth.

00:42:13.000 --> 00:42:22.000
So the syntax is whatever the return type, so greater than returns a bool, equals, equals returns a bool.

00:42:22.000 --> 00:42:27.000
Plus would return whatever type this object type is.

00:42:27.000 --> 00:42:31.000
So it could be an int, it could be a double, it could be a star.

00:42:31.000 --> 00:42:39.000
And so it's the return type, say bool, the operator, and then the symbol used for the operator.

00:42:39.000 --> 00:42:46.000
The symbol used for the operator, so operator greater than, operator equals, equals.

00:42:46.000 --> 00:42:50.000
And then the two arguments that will appear on the left-hand side and the right.

00:42:50.000 --> 00:42:56.000
So LHS here just means the left-hand side, RHS just means the right-hand side.

00:42:56.000 --> 00:43:01.000
And again, we replace the question mark here with the operator symbol.

00:43:01.000 --> 00:43:07.000
So, suppose we wanted to compare star operators by magnitude.

00:43:07.000 --> 00:43:11.000
If we wanted to do that, we'd use the less than operator.

00:43:11.000 --> 00:43:15.000
So notice the function is named operator less than.

00:43:15.000 --> 00:43:18.000
Less than returns a bool, true or false.

00:43:18.000 --> 00:43:25.000
Would take two const stars, so const star ref LHS, const star ref RHS.

00:43:25.000 --> 00:43:37.000
And then would return true if the magnitude of the left-hand side was less than the magnitude on the right-hand side.

00:43:37.000 --> 00:43:44.000
Now, what we'd like to do now is we'd like to overload the input and output operators.

00:43:44.000 --> 00:43:48.000
So the output operators have this prototype.

00:43:48.000 --> 00:43:53.000
Now, that should look familiar to you as well as that one.

00:43:53.000 --> 00:44:01.000
The only difference between read and print and these operators is the name of the function.

00:44:01.000 --> 00:44:08.000
So, almost exactly the same signature as print and read, but with different names.

00:44:08.000 --> 00:44:15.000
And so we can implement those by using read and print to implement them.

00:44:15.000 --> 00:44:17.000
So we're going to go ahead and do that.

00:44:17.000 --> 00:44:23.000
We're going to complete our second exercise here by adding these two member functions,

00:44:23.000 --> 00:44:28.000
or these two overloaded operators to our code.

00:44:28.000 --> 00:44:37.000
So in stars.h, we're going to take, make a copy of these two.

00:44:37.000 --> 00:44:44.000
And I'm simply going to name this one operator output.

00:44:44.000 --> 00:44:46.000
It's an O-string.

00:44:46.000 --> 00:44:52.000
And this one I'm going to name operator input.

00:44:52.000 --> 00:44:55.000
It's an I-string.

00:44:55.000 --> 00:45:02.000
So notice that I used exactly the same prototype, just with a different name.

00:45:02.000 --> 00:45:08.000
I'm going to copy it over to stars.cpp.

00:45:08.000 --> 00:45:11.000
I'm going to paste them up here.

00:45:11.000 --> 00:45:15.000
Remove the semicolon.

00:45:15.000 --> 00:45:18.000
Remove the semicolon here.

00:45:18.000 --> 00:45:35.000
And since we've already implemented that functionality as a function, I can just say return print out s.

00:45:35.000 --> 00:45:43.000
And for this one I can just say return read in s.

00:45:43.000 --> 00:45:51.000
So I'm using these functions up here that we wrote by hand to implement our overloaded operators.

00:45:51.000 --> 00:46:13.000
And if you come down to run, now we can go ahead and comment out the remainder of this.

00:46:13.000 --> 00:46:22.000
The remainder of that. And we should be able to do make run again.

00:46:22.000 --> 00:46:29.000
And notice that the input and output operators work perfectly fine.

00:46:29.000 --> 00:46:32.000
And reading from a string works perfectly fine.

00:46:32.000 --> 00:46:38.000
So we can pass a string stream, you notice, for this third part.

00:46:38.000 --> 00:46:41.000
I've just created an I-string stream with some values in it.

00:46:41.000 --> 00:46:45.000
I pass it to read and it works perfectly fine.

00:46:45.000 --> 00:46:55.000
And the input operators, so notice for part two here, rather than saying while read in s, I'm saying while in arrow s.

00:46:55.000 --> 00:46:58.000
And here I'm saying cout arrow arrow s.

00:46:58.000 --> 00:47:03.000
So I'm using exactly the same syntax.

00:47:03.000 --> 00:47:07.000
So to finish this up, make sure the run part works.

00:47:07.000 --> 00:47:11.000
Go ahead and just do make test.

00:47:11.000 --> 00:47:16.000
And it will test running and looking at several different kinds of stars.

00:47:16.000 --> 00:47:20.000
Testing individually the output operator to make sure that it's correct.

00:47:20.000 --> 00:47:23.000
Testing individually the input operator.

00:47:23.000 --> 00:47:27.000
Again, this is what the input is. Here's one with two names.

00:47:27.000 --> 00:47:31.000
We test it with one name. Test it with one with no name.

00:47:31.000 --> 00:47:35.000
So we can test all those possibilities.

00:47:35.000 --> 00:47:42.000
And this is just testing read and print separately.

00:47:42.000 --> 00:47:48.000
So here's testing read. Here's testing print.

00:47:48.000 --> 00:47:54.000
Here's testing the input operator. Here's testing the output operator.

00:48:02.000 --> 00:48:08.000
Okay, so structured types are things like the date that you see on the right.

00:48:08.000 --> 00:48:13.000
It has January 3rd, 2009.

00:48:13.000 --> 00:48:17.000
It has a string and a couple of integers.

00:48:17.000 --> 00:48:19.000
So that's a structured type.

00:48:19.000 --> 00:48:23.000
We can also create user defined scalar types.

00:48:23.000 --> 00:48:33.000
Ones that have only a single value versus the structured type or the record that adds multiple values together.

00:48:33.000 --> 00:48:41.000
With scalar values, we can enumerate, meaning we can list or count each possible value.

00:48:41.000 --> 00:48:46.000
For instance, if I want to create a type that represents the weekdays,

00:48:46.000 --> 00:48:50.000
it's Monday, Tuesday, Wednesday, Thursday, and Friday.

00:48:50.000 --> 00:48:55.000
Saturday and Sunday wouldn't be one of the weekdays.

00:48:55.000 --> 00:48:59.000
We can write this two ways.

00:48:59.000 --> 00:49:06.000
In C++11, we use the words "anum" followed by "class".

00:49:06.000 --> 00:49:09.000
So anum, class, weekday.

00:49:09.000 --> 00:49:11.000
These are called scoped enumerations.

00:49:11.000 --> 00:49:15.000
They were introduced again in C++11.

00:49:15.000 --> 00:49:23.000
C++ and C, the older version of C++, that's what's called a plain enumeration.

00:49:23.000 --> 00:49:31.000
You generally want to use the scoped enumerations because they have less opportunities for errors.

00:49:31.000 --> 00:49:37.000
So let's look at defining an enumerated type.

00:49:37.000 --> 00:49:45.000
So an enumerated type is a set of related integer values which act like a type.

00:49:45.000 --> 00:49:48.000
You provide a name for each value.

00:49:48.000 --> 00:50:00.000
For example, the suit values for a deck of cards would include the clubs, the spades, the diamonds, and the hearts.

00:50:00.000 --> 00:50:03.000
Now notice the names are separated by commas.

00:50:03.000 --> 00:50:09.000
There's no ending semicolon. There's an ending semicolon at the end of the definition of the type.

00:50:09.000 --> 00:50:13.000
But there's no semicolon after the word "hearts".

00:50:13.000 --> 00:50:15.000
So no ending semicolon.

00:50:15.000 --> 00:50:22.000
You should use lowercase or propercase. Avoid using uppercase.

00:50:22.000 --> 00:50:29.000
Here are some of the things you can do with a scoped enumeration.

00:50:29.000 --> 00:50:35.000
I could create a suit variable, S, an enumerated type variable.

00:50:35.000 --> 00:50:38.000
I could initialize it. What would I initialize it with?

00:50:38.000 --> 00:50:46.000
I'd initialize it not with hearts, but with its fully qualified name, suit colon colon hearts.

00:50:46.000 --> 00:50:50.000
I could compare it to another enumerated type.

00:50:50.000 --> 00:50:58.000
I couldn't compare it to an integer, but I could compare it to suit clubs using not equals and equals.

00:50:58.000 --> 00:51:05.000
Now greater than and less than also kind of works, but it's not very, very useful.

00:51:05.000 --> 00:51:09.000
So generally we'll use equals or not equals.

00:51:09.000 --> 00:51:13.000
We can use that variable as a switch selector.

00:51:13.000 --> 00:51:21.000
So switch S, case suit clubs, return clubs. Case suit hearts, return hearts.

00:51:21.000 --> 00:51:28.000
So this is converting a suit type into a string type.

00:51:28.000 --> 00:51:34.000
If it wasn't one of the four clubs, which are the only things it could possibly be,

00:51:34.000 --> 00:51:41.000
would return some kind of error or have an assertion there or throw an exception, something like that.

00:51:41.000 --> 00:51:47.000
So why do we want to use enumerated types?

00:51:47.000 --> 00:51:49.000
Consider a playing card.

00:51:49.000 --> 00:51:51.000
A playing card has two things.

00:51:51.000 --> 00:51:55.000
It has a suit and a rank.

00:51:55.000 --> 00:52:01.000
We could represent that suit and that rank like ace, king, queen, jack is the rank,

00:52:01.000 --> 00:52:06.000
and diamonds, hearts, spades, and clubs are the suits.

00:52:06.000 --> 00:52:12.000
We could represent those by using strings or integers or something else.

00:52:12.000 --> 00:52:19.000
So imagine if we represented the rank and the suit using strings.

00:52:19.000 --> 00:52:22.000
There should be a comma between rank and suit here,

00:52:22.000 --> 00:52:27.000
and I will probably fix that on the slides that you'll see if you click the slides.

00:52:27.000 --> 00:52:34.000
Then I go and create a card object.

00:52:34.000 --> 00:52:39.000
And I create a card A and I pass it ace and clubs.

00:52:39.000 --> 00:52:41.000
Well, what's the problem?

00:52:41.000 --> 00:52:46.000
Well, cubs is the wrong spelling for the clubs,

00:52:46.000 --> 00:52:51.000
so instead of the ace of clubs, I get something that doesn't make any sense.

00:52:51.000 --> 00:52:54.000
In other words, my type is not very resilient.

00:52:54.000 --> 00:53:00.000
The compiler can't check the fact that I've passed the wrong values.

00:53:00.000 --> 00:53:05.000
Suppose instead I decide to make rank and suit integers.

00:53:05.000 --> 00:53:14.000
And then I create some constants like this, ace 101 and clubs 1001.

00:53:14.000 --> 00:53:20.000
So I start all the ranks at 1 and I start all the suits at 1000.

00:53:20.000 --> 00:53:26.000
And then I try and create a card B, clubs ace.

00:53:26.000 --> 00:53:28.000
Well, what's the problem?

00:53:28.000 --> 00:53:31.000
Again, my structure has rank and suit.

00:53:31.000 --> 00:53:40.000
What I've passed in is 1001 for the rank and 101 for the suit.

00:53:40.000 --> 00:53:46.000
Both of those are invalid values, and I would have to do some extra checking.

00:53:46.000 --> 00:53:53.000
Again, the compiler can't check to see that I have switched my rank and suit,

00:53:53.000 --> 00:53:57.000
where it's supposed to be rank suit, and I've passed in clubs.

00:53:57.000 --> 00:54:00.000
I've passed in suit and rank.

00:54:00.000 --> 00:54:03.000
Again, the compiler can't change that.

00:54:03.000 --> 00:54:08.000
Suppose, however, that I created an enumerated type for the rank,

00:54:08.000 --> 00:54:11.000
an enumerated type for the suit.

00:54:11.000 --> 00:54:18.000
Then I would create it like this, card rank ace, rank clubs.

00:54:18.000 --> 00:54:21.000
If I switch those, the compiler would tell me.

00:54:21.000 --> 00:54:25.000
I would know the moment I tried to compile my code, I've made a mistake.

00:54:25.000 --> 00:54:32.000
I would not have to ever worry about creating a card object with invalid values.

00:54:32.000 --> 00:54:35.000
It would be impossible.

00:54:35.000 --> 00:54:40.000
And so that's really why we want to use enumerated types.

00:54:40.000 --> 00:54:48.000
We say that we're creating strong types for our arguments and our parameters.

00:54:48.000 --> 00:54:54.000
Now, there is no built-in input/output with enumerated types.

00:54:54.000 --> 00:54:57.000
You may write a two-string function.

00:54:57.000 --> 00:55:02.000
You may want to convert it to a string for output with a function.

00:55:02.000 --> 00:55:06.000
So here's a two-string function that takes a rank.

00:55:06.000 --> 00:55:11.000
We'll switch on the rank, and then case rank ace, we'll return ace.

00:55:11.000 --> 00:55:18.000
Case rank two, we'll return two. Case rank three, we'll return three.

00:55:18.000 --> 00:55:21.000
So let's go ahead and do that.

00:55:21.000 --> 00:55:24.000
So for our exercise here with enumerated types,

00:55:24.000 --> 00:55:37.000
we're going to take the coin type and we're going to complete the two-string function for the coin type.

00:55:37.000 --> 00:55:40.000
So let me close that.

00:55:40.000 --> 00:55:44.000
Let me close this. Let me close this.

00:55:44.000 --> 00:55:48.000
Let's go down to C.

00:55:48.000 --> 00:55:51.000
And this will be in enumH.

00:55:51.000 --> 00:55:55.000
So here's our enumerated type.

00:55:55.000 --> 00:55:59.000
And we're going to write the two-string function.

00:55:59.000 --> 00:56:05.000
And let's see if we want to do the two-string and the value of function.

00:56:05.000 --> 00:56:09.000
So actually we're going to write two functions in this.

00:56:09.000 --> 00:56:16.000
And so this is in enumOps.cpp.

00:56:16.000 --> 00:56:24.000
So let's put your name in here.

00:56:24.000 --> 00:56:28.000
Notice I've included enum.h right here.

00:56:28.000 --> 00:56:35.000
I'm going to put my name at the top of this just to get the practice.

00:56:35.000 --> 00:56:40.000
So I'm going to put summer22 for this.

00:56:40.000 --> 00:56:47.000
Okay, let's go grab those two prototypes.

00:56:47.000 --> 00:57:05.000
And we'll see how we would add our implementation for that right here.

00:57:05.000 --> 00:57:15.000
Okay, so if I want to convert a coin object to string, I'm going to have to use a switch statement.

00:57:15.000 --> 00:57:23.000
So I'm going to have to say switch on C.

00:57:23.000 --> 00:57:30.000
Now I'm going to have to say case coin colon colon and then what the coin types are.

00:57:30.000 --> 00:57:32.000
So what are my coin types?

00:57:32.000 --> 00:57:50.000
I'll just copy them right here.

00:57:50.000 --> 00:57:56.000
So case coin penny colon.

00:57:56.000 --> 00:57:58.000
So that's the structure.

00:57:58.000 --> 00:58:01.000
The colon colon and the colon is kind of confusing here.

00:58:01.000 --> 00:58:14.000
I'm going to return penny.

00:58:14.000 --> 00:58:35.000
And this will be case coin dime, case coin quarter, case coin nickel.

00:58:35.000 --> 00:58:54.000
Let's put the colons on the end of each of those case labels.

00:58:54.000 --> 00:59:02.000
So here we're going to return nickel.

00:59:02.000 --> 00:59:09.000
Here we're going to return a dime.

00:59:09.000 --> 00:59:19.000
Here I'm going to return a quarter.

00:59:19.000 --> 00:59:27.000
And here I'm going to return half dollar.

00:59:27.000 --> 00:59:29.000
Okay, what if it is none of those?

00:59:29.000 --> 00:59:33.000
Well, technically it has to be one of those.

00:59:33.000 --> 00:59:38.000
I believe the code will compile without us putting a default in it.

00:59:38.000 --> 00:59:39.000
Let's just try it.

00:59:39.000 --> 00:59:45.000
Let's open up a shell on that.

00:59:45.000 --> 00:59:49.000
Let's just do make on it.

00:59:49.000 --> 00:59:54.000
Okay, value of, okay, control reaches end of non-void function.

00:59:54.000 --> 00:59:59.000
So it does require us to do something.

00:59:59.000 --> 01:00:16.000
And so what we could do here is we could just add an assert or a throw or just a return.

01:00:16.000 --> 01:00:20.000
Or you could add a throw statement.

01:00:20.000 --> 01:00:24.000
A throw would work fine.

01:00:24.000 --> 01:00:41.000
And we could put this, of course, inside the default.

01:00:41.000 --> 01:00:44.000
In which case we don't need it here.

01:00:44.000 --> 01:00:51.000
It's maybe a little more obvious over there that that is an error in that case.

01:00:51.000 --> 01:00:55.000
Okay, so now we've got a coin and we want to get its value.

01:00:55.000 --> 01:00:59.000
Now we could do a switch like this, case coin penny, return one.

01:00:59.000 --> 01:01:02.000
Case coin nickel, return two.

01:01:02.000 --> 01:01:05.000
But notice when I created my enumerated type,

01:01:05.000 --> 01:01:15.000
I provided an underlying value for each of the types that represents the type of the value.

01:01:15.000 --> 01:01:18.000
Now we want to return it as a double.

01:01:18.000 --> 01:01:28.000
And so what we're going to need to do is we're going to need to cast this to its underlying type.

01:01:28.000 --> 01:01:46.000
So I'm going to say static return static cast double C divided by 100.

01:01:46.000 --> 01:01:51.000
And this actually should be, you should cast it to an int, not a double.

01:01:51.000 --> 01:01:57.000
So static cast int divided by 100 will give us a double.

01:01:57.000 --> 01:02:04.000
And that should, in fact, pass all our tests.

01:02:04.000 --> 01:02:08.000
Make works, so make test.

01:02:08.000 --> 01:02:15.000
And to string, oh, it wanted half dollar to look slightly different, so let's fix that.

01:02:15.000 --> 01:02:24.000
It wants it to look like that.

01:02:24.000 --> 01:02:27.000
So let's say make test.

01:02:27.000 --> 01:02:36.000
Okay, so all of these work.

01:02:36.000 --> 01:02:45.000
Okay, so this was converting a type, an enumerated type to a two string,

01:02:45.000 --> 01:02:49.000
so we could do output on it and a value of,

01:02:49.000 --> 01:02:54.000
so we could use it in a calculation, a coin type rather than an integer.

01:02:54.000 --> 01:02:58.000
I could use it with other types.

01:02:58.000 --> 01:03:05.000
Okay, the last thing we want to look at today in this lecture is we want to look at I/O operators.

01:03:05.000 --> 01:03:09.000
So I've already seen these I/O operators for stars.

01:03:09.000 --> 01:03:11.000
We have const star ref.

01:03:11.000 --> 01:03:22.000
We can use them for any user defined types, including for enumerated types.

01:03:22.000 --> 01:03:28.000
So we're going to use the two string for rank and suit.

01:03:28.000 --> 01:03:31.000
Card, of course, is a structure in this case,

01:03:31.000 --> 01:03:37.000
so we can use the output operators for our cards just like we did with our stars.

01:03:37.000 --> 01:03:44.000
The input operator looks like this, just like the ones we used for stars.

01:03:44.000 --> 01:03:53.000
Our input is going to be in the form of AS for ace of spades, TH for ten of hearts,

01:03:53.000 --> 01:03:57.000
JC for jack of clubs, and so forth.

01:03:57.000 --> 01:04:07.000
So this is our last exercise. We're going to write the card I/O operators down in,

01:04:07.000 --> 01:04:11.000
let's close that,

01:04:11.000 --> 01:04:17.000
down in D.

01:04:17.000 --> 01:04:22.000
So let's open a shell on that.

01:04:22.000 --> 01:04:29.000
And let's close the previous shells.

01:04:29.000 --> 01:04:33.000
And so I only have one shell open on D.

01:04:33.000 --> 01:04:42.000
Let's open card I/O dot CVP. This is the one we're going to change.

01:04:42.000 --> 01:04:47.000
Cards dot H, I believe, already has our prototypes inside there.

01:04:47.000 --> 01:04:52.000
So we can just copy those prototypes, that's what we're going to write.

01:04:52.000 --> 01:05:07.000
It has these functions already written, the two string for the suit and the two string for the rank.

01:05:07.000 --> 01:05:10.000
So the output one is pretty easy.

01:05:10.000 --> 01:05:27.000
The output one, we're simply going to say out, two string, C dot rank.

01:05:27.000 --> 01:05:39.000
Then we're going to put of, and two string, C dot suit.

01:05:39.000 --> 01:05:41.000
And then we're going to return out.

01:05:41.000 --> 01:05:52.000
So that's pretty easy. We're taking two string, and again, that's already defined for us here.

01:05:52.000 --> 01:05:55.000
And here are the types for suits and ranks.

01:05:55.000 --> 01:06:00.000
So we don't need to use a switch statement for that.

01:06:00.000 --> 01:06:06.000
This is our structure for our card. It has a rank and a suit.

01:06:06.000 --> 01:06:11.000
So the output is pretty easy. The input is a little more difficult.

01:06:11.000 --> 01:06:15.000
So we're going to return in at the end of this.

01:06:15.000 --> 01:06:18.000
We're going to need to read two characters.

01:06:18.000 --> 01:06:21.000
So I'm going to call those R and C.

01:06:21.000 --> 01:06:25.000
So char R and C.

01:06:25.000 --> 01:06:31.000
And we're going to need to read in R and C.

01:06:31.000 --> 01:06:39.000
Now there is no easy way to compute, convert R to C, other than writing a switch.

01:06:39.000 --> 01:06:54.000
So we're going to write switch R, and then switch C.

01:06:54.000 --> 01:07:03.000
Now the parts that make up a rank, let's just go copy them over here.

01:07:03.000 --> 01:07:07.000
There's our suit.

01:07:07.000 --> 01:07:19.000
So let me just copy both of those over here.

01:07:19.000 --> 01:07:26.000
Okay, so here's our ranks.

01:07:26.000 --> 01:07:31.000
Now that's our suits.

01:07:31.000 --> 01:07:34.000
Let's paste them in there and comment them out.

01:07:34.000 --> 01:07:45.000
Here's our ranks.

01:07:45.000 --> 01:07:57.000
And I should have called this R and S, right? Rank and suit.

01:07:57.000 --> 01:08:01.000
Okay, so there's my ranks.

01:08:01.000 --> 01:08:05.000
Here's my suit.

01:08:05.000 --> 01:08:09.000
Okay, so let's put the syntax in there.

01:08:09.000 --> 01:08:25.000
So case rank colon colon ace.

01:08:25.000 --> 01:08:34.000
What we're going to say is C rank equals.

01:08:34.000 --> 01:08:39.000
Of course, let me put this. I'm really messing this up.

01:08:39.000 --> 01:09:00.000
Case ace, then C.rank equals rank.ace and break.

01:09:00.000 --> 01:09:10.000
Okay, so we're going to do the same thing. I'm just going to copy that code there.

01:09:10.000 --> 01:09:14.000
Let's put in all the ranks.

01:09:14.000 --> 01:09:26.000
Two, three, four, five, six, seven, eight, nine.

01:09:26.000 --> 01:09:31.000
Can't put ten as a character, so we're going to use T.

01:09:31.000 --> 01:09:40.000
Jack, queen, and one more.

01:09:40.000 --> 01:09:49.000
King.

01:09:49.000 --> 01:09:54.000
So this is going to be.

01:09:54.000 --> 01:10:22.000
So that's going to be two. Three. Four. Five. Six. Seven. Eight.

01:10:22.000 --> 01:10:27.000
Oops.

01:10:27.000 --> 01:10:50.000
Eight. Nine. Ten. Jack. Queen. King.

01:10:50.000 --> 01:11:00.000
And let's put a default.

01:11:00.000 --> 01:11:05.000
Let's throw an exception.

01:11:05.000 --> 01:11:17.000
Throw a string.

01:11:17.000 --> 01:11:21.000
Throw a bad rank.

01:11:21.000 --> 01:11:23.000
Okay, now let me copy one of these lines here.

01:11:23.000 --> 01:11:27.000
We'll use the same thing for the suit.

01:11:27.000 --> 01:11:35.000
Although, of course, it's much closer. It's very shorter.

01:11:35.000 --> 01:11:46.000
So the suits are going to be spades, clubs, C suit.

01:11:46.000 --> 01:11:50.000
That should be C, right?

01:11:50.000 --> 01:12:00.000
And this is going to be suit clubs.

01:12:00.000 --> 01:12:19.000
And we can just make. I'm not quite sure what I did.

01:12:19.000 --> 01:12:30.000
So here's spades, diamonds, hearts.

01:12:30.000 --> 01:12:37.000
And this, of course, is S, D, and H.

01:12:37.000 --> 01:12:39.000
And we'll do the same thing for the default.

01:12:39.000 --> 01:12:55.000
I'll just throw a bad suit instead of a bad rank.

01:12:55.000 --> 01:12:58.000
Okay, let's try it here.

01:12:58.000 --> 01:13:02.000
So let's do make.

01:13:02.000 --> 01:13:06.000
And let's do make test.

01:13:06.000 --> 01:13:10.000
Okay, so here's my output operator. I created this car with rank of ace.

01:13:10.000 --> 01:13:12.000
It prints out ace of spades.

01:13:12.000 --> 01:13:17.000
Queen of hearts. Jack of diamonds.

01:13:17.000 --> 01:13:22.000
Now I've created a, I've got in seven of clubs.

01:13:22.000 --> 01:13:25.000
If you want to see what I'm processing, I'm processing this file.

01:13:25.000 --> 01:13:33.000
Seven of clubs, two of diamonds, ten of diamonds, ten of clubs, queen of hearts.

01:13:33.000 --> 01:13:38.000
And if we look at the output,

01:13:38.000 --> 01:13:45.000
what we got is seven of clubs, two of diamonds, ten of diamonds, ten of clubs, queen of hearts.

01:13:45.000 --> 01:13:51.000
So that worked just perfectly.

01:13:51.000 --> 01:13:54.000
Okay, so we went a little over an hour today.

01:13:54.000 --> 01:13:59.000
But we covered structured types and enumerated types.

01:13:59.000 --> 01:14:03.000
And you were introduced to overloaded operators.

01:14:03.000 --> 01:14:07.000
I'll see you in lecture 16.

